% arara: PDFLaTeX
% arara: nomencl
% arara: PDFLaTeX
\documentclass[a4paper,12pt]{report}
\usepackage[utf8]{vietnam}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{comment}
%\usepackage{enumitem}
\usepackage{enumerate}
%\usepackage{amssymb}
\usepackage{graphicx}
%\usepackage{cases}
\usepackage{fancybox}
\usepackage{multirow}
\usepackage{longtable,booktabs}
\usepackage{listings}
\usepackage[nottoc]{tocbibind}
\usepackage{indentfirst}
\usepackage[english]{babel}
\usepackage{algpseudocode}
\usepackage{subcaption}
%\usepackage[refpage]{nomencl}

%\makenomenclature
\usepackage{acro}
\acsetup{
  only-used = false,
  list-style = extra-tabular
}

\usepackage{algorithm}
\usepackage{float}
\usepackage{tikz}
\usepackage{pgfplots}

\usepackage{tikz-uml}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{shapes.geometric}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}  
\usepackage[left=3cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
%\lstset{
   %keywords={break,case,catch,continue,else,elseif,end,for,function,
   %   global,if,otherwise,persistent,return,switch,try,while},
%   language = Java,
%   basicstyle=\ttfamily \fontsize{12}{15}\selectfont,   
	% numbers=left,
%   frame=lrtb,
%tabsize=3
%}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=blue,
    urlcolor=red 
}
\setlength{\parskip}{0.6em}
\addto\captionsenglish{%
 \renewcommand\chaptername{Chương}
 \renewcommand{\contentsname}{Mục lục} 
 \renewcommand{\listtablename}{Danh sách bảng}
 \renewcommand{\listfigurename}{Danh sách hình vẽ}
 \renewcommand{\tablename}{Bảng}
 \renewcommand{\figurename}{Hình}
 \renewcommand{\bibname}{Tài liệu tham khảo}
}

\makeatletter
\newcommand{\vast}{\bBigg@{4}}
\newcommand{\Vast}{\bBigg@{5}}
\newcommand{\vastl}{\mathopen\vast}
\newcommand{\vastm}{\mathrel\vast}
\newcommand{\vastr}{\mathclose\vast}
\newcommand{\Vastl}{\mathopen\Vast}
\newcommand{\Vastm}{\mathrel\Vast}
\newcommand{\Vastr}{\mathclose\Vast}
\makeatother

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\newtheorem{definition}{Định nghĩa}[chapter]
%\newtheorem{lema}{Bổ đề}[chapter]
%\newtheorem{theorem}{Định lý}[chapter]
%Bang chu viet tắt---------------
\DeclareAcronym{ERP}{
  short = ERP ,
  long  = Enterprise Resource Planning - Quản trị doanh nghiệp ,
  class = abbrev
}
\DeclareAcronym{JSP}{
  short = JSP ,
  long  = Java Server Pages ,
  class = abbrev
}
\DeclareAcronym{FTL}{
  short = FTL ,
  long  = FreeMarker Template Language ,
  class = abbrev
}
\DeclareAcronym{SOAP}{
  short = SOAP ,
  long  = simple object access protocol là một dạng web service ,
  class = abbrev
}
\DeclareAcronym{GRASP}{
  short = GRASP ,
  long  = A Greedy Randomized Adaptive Search Procedure,
  class = abbrev
}
\DeclareAcronym{TSP}{
  short = TSP ,
  long  = Traveling salesman problem,
  class = abbrev
}
\DeclareAcronym{TSPD}{
  short = TSPD ,
  long  = Traveling salesman problem with Drone,
  class = abbrev
}

\DeclareAcronym{TSPkD}{
  short = TSPkD ,
  long  = Traveling salesman problem with k Drones,
  class = abbrev
}
\DeclareAcronym{CSP}{
  short = CSP ,
  long  = bài toán thỏa mãn ràng buộc - Constraint Satisfaction Problem ,
  class = abbrev
}
\DeclareAcronym{DD}{
  short = DD ,
  long  = một chuyến giao hàng bởi drone - drone delivery ,
  class = abbrev
}

\DeclareAcronym{TD}{
  short = TD ,
  long  = một hành trình giao hàng bởi xe tải - truck delivery,
  class = abbrev
}

\DeclareAcronym{MIP}{
  short = MIP ,
  long  = Mixed Integer Programming,
  class = abbrev
}

\DeclareAcronym{FSTSP}{
  short = FSTSP ,
  long  = Flying Sidekick Traveling Salesman Problem,
  class = abbrev
}
\DeclareAcronym{GTSP}{
  short = GTSP ,
  long  = Generalized Traveling
Salesman Problem,
  class = abbrev
}

\DeclareAcronym{HDP}{
  short = HDP ,
  long  = Heterogeneous Delivery Problem,
  class = abbrev
}
% class `nomencl': nomenclature

%--------------------------------
\begin{document}
\thispagestyle{empty}
\thisfancypage{
\setlength{\fboxrule}{1pt}
\doublebox}{}

\begin{center}
{\fontsize{16}{19}\fontfamily{cmr}\selectfont TRƯỜNG ĐẠI HỌC BÁCH KHOA HÀ NỘI\\
VIỆN CÔNG NGHỆ THÔNG TIN VÀ TRUYỀN THÔNG}\\
\textbf{------------*******---------------}\\[1cm]
\includegraphics[scale=0.13]{hust.jpg}\\[1.3cm]
{\fontsize{23}{43}\fontfamily{cmr}\selectfont ĐỒ ÁN TỐT NGHIỆP}\\[0.1cm]
{\fontsize{25}{10}\fontfamily{cmr}\fontseries{b}\selectfont NGÀNH KHOA HỌC MÁY TÍNH}\\[0.9cm]
{\fontsize{20}{24}\fontfamily{phv}\selectfont Phát triển thuật toán tìm kiếm cục bộ cho bài toán lập lộ trình giao hàng kết hợp xe tải và thiết bị bay drone}\\[2.5cm]

\hspace{-6cm}\fontsize{14}{16}\fontfamily{cmr}\selectfont \textbf{Sinh viên thực hiện :}\\[0.1cm] 
\begin{longtable}{l c c}
Nguyễn Tuấn Đạt & 20130856 & CNTT2.02-K58 
\end{longtable}
\vspace{0.3cm}
\hspace{-6cm}\fontsize{14}{16}\fontfamily{cmr}\selectfont \textbf{Giảng viên hướng dẫn :}\\[0.1cm]
\hspace{-2.7cm}\fontsize{14}{16}\fontfamily{cmr}\selectfont TS. Phạm Quang Dũng \\[3cm]
\fontsize{16}{19}\fontfamily{cmr}\selectfont Hà Nội 12--2017
\end{center}
\addcontentsline{toc}{chapter}{Lời cảm ơn}
\chapter*{Lời cảm ơn}
Trước khi trình bày nội dung của đồ án này, tôi xin được gửi lời cảm ơn sâu sắc và chân thành nhất đến TS. Phạm Quang Dũng, người đã tận tình hướng đẫn tôi trong suốt quá trình thực hiện đồ án này cũng như những năm tháng học tại trường Đại học Bách Khoa Hà Nội. Đồng thời tôi cũng xin bày tỏ lòng biết ơn đến các thầy cô trường Đại học Bách Khoa Hà Nội, Viện công nghệ thông tin và truyền thông, đặc biệt là các thầy cô bộ môn Khoa học máy tính đã tận tình chỉ dạy cho tôi trong những năm tháng học tập ở trường. \\ 

Tôi cũng xin bày tỏ lòng biết ơn đến các anh chị ở công ty cổ phần OLBIUS đã nhiệt tình giúp đỡ tôi phần công nghệ cho đồ án này. Cùng với đó, tôi cũng xin cảm ơn các anh chị ở lab MSO đã giúp đỡ tôi trong những năm tháng tôi sinh hoạt ở lab.\\

Cuối cùng tôi xin gửi lời cảm ơn đến gia đình, bạn bè đã luôn ở bên tôi, đông viên và giúp đỡ tôi trong suốt quá trình học tập và thực hiện đồ án tốt nghiệp. 
\newpage
\pdfbookmark{\contentsname}{toc}

\tableofcontents
\newpage
\addcontentsline{toc}{chapter}{Bảng chữ viết tắt}
\chapter*{Bảng chữ viết tắt}
%\printacronyms[include-classes=abbrev,heading=none,sort=false]
\begin{longtable}{|l|l|}
\toprule
Chữ viết tắt & Tên đầy đủ\\
\midrule
        \toprule
ERP &  Hệ thống quản trị doanh nghiệp - Enterprise Resource Planning \\ \hline
JSP &  Java Server Pages \\ \hline
FTL & FreeMarker Template Language \\ \hline
SOAP & Simple object access protocol (một dạng web service) \\ \hline
GRASP & A Greedy Randomized Adaptive Search Procedure \\ \hline
TSP & Traveling salesman problem \\ \hline
TSPD & Traveling salesman problem with Drone \\ \hline
TSPkD & Traveling salesman problem with k Drones \\ \hline
CSP & Bài toán thỏa mãn ràng buộc - Constraint Satisfaction Problem \\ \hline
DD & Một chuyến giao hàng bởi drone - Drone delivery  \\ \hline
TD & Một hành trình giao hàng bởi xe tải - Truck delivery \\ \hline
MIP &  Mixed Integer Programming \\ \hline
FSTSP & Flying Sidekick Traveling Salesman Problem \\ \hline
GTSP & Generalized Traveling Salesman Problem \\ \hline
HDP & Heterogeneous Delivery Problem \\ \hline
\end{longtable}
%\printacronyms[include-classes=nomencl,name=Danh mục]
\listoftables
\listoffigures


%\printnomenclature
\addcontentsline{toc}{chapter}{Mở đầu}
\chapter*{Giới thiệu chung}
Bài toán lập lịch vận chuyển hàng hóa từ lâu đã là lớp bài toán tối ưu hóa quan trọng và có tính thực tiễn cao. Công nghệ ngày càng phát triển, đặc biệt gần đây, phương tiện bay không người lái trở phổ biến với nhiều mẫu mã đặc trưng cho các mục đích sử dụng khác nhau. Thiết bị bay không người lái (hay còn gọi là drone) đã và đang được nghiên cứu sử dụng trong ngành công nghiệp vận chuyển hàng hóa. Với công nghệ hiện nay, drone có thể nâng những vật có khối lượng hàng chục kilogram và quãng đường bay có thể đạt đến hàng chục kilometers. Những đặc tính trên khiến thiết bị bay không người lái có thể là xu hướng trong nhiều năm tới đây.

Trong thời buổi công nghệ thông tin phát triển rộng khắp như hiện nay. Bài toán lập lịch vận chuyển hàng hóa gần như là một phần không thể thiếu trong hệ thống \ac{ERP} của các công ti vận tải hàng đầu thế giới. Chính vì vậy trong đồ án này, chúng tôi đã phát triển và cài đặt mô hình thuật toán tìm kiếm cục bộ cho bài toán lập lộ trình giao hàng kết hợp xe tải và thiết bị bay không người lái ứng dụng vào công nghệ Ofbiz dưới dạng web service. Ofbiz là một ứng dụng mã nguồn mở về \ac{ERP} được Apache phát triển từ năm 2001. Ofbiz cho phép lập trình viện có thể can thiệp, thay đổi hệ thống linh hoạt cũng như có khả năng phát triển một ứng dụng độc lập hoàn chỉnh. 

Nội dung chính của đồ án bao gồm 6 chương:
\begin{itemize}
\item \textbf{Chương 1:} Cơ sở lý thuyết
\item \textbf{Chương 2:} Bài toán lập lộ trình giao hàng kết hợp một xe tải với một thiết bị bay cùng các nghiên cứu liên quan.
\item \textbf{Chương 3:} Đề xuất thuật toán tìm kiếm cục bộ giải bài toán lập lộ trình vận tải giao hàng kết hợp một xe tải và nhiều thiết bị bay.
\item \textbf{Chương 4:} Thử nghiệm và đánh giá.
\item \textbf{Chương 5:} Thiết kế chương trình ứng dụng.
\item \textbf{Chương 6:} Kết luận và hướng phát  triển.
\end{itemize}

\chapter{Cơ sở lý thuyết}
Trong chương này chúng tôi sẽ trình bày cơ sở lý thuyết chung cho bài toán tối ưu hóa tổ hợp, tối ưu hóa thỏa mãn ràng buộc. Các định nghĩa bài toán tối ưu hóa tổ hợp, bài toán thỏa mãn ràng buộc và ứng dụng được trình bày trong phần \ref{section:cbo}. Ở phần \ref{section:cbs} chúng tôi trình bày hai hướng tiếp cận giải bài toán thỏa mãn ràng buộc là thuật toán giải đúng và thuật toán giải gần đúng. Trong phần \ref{section:ofbiz}, chúng tôi giới thiệu tổng quan về công nghệ chính xây dựng module ứng dụng cho đồ án này là công nghệ Ofbiz. Các tài liệu tham khảo chúng tôi sử dụng trong phần này là \cite{csplib30}, \cite{AIAMAB},  \cite{HCP}, \cite{IP},  \cite{TRR},  \cite{AOW}.
\section{Tối ưu hóa tổ hợp và ứng dụng}
\label{section:cbo}
\subsection{Tối ưu hóa tổ hợp}
Bài toán tối ưu hóa tổ hợp (Combinatorial Optimization Problem) \cite{IP}, \cite{TRR} dưới dạng tổng quát có thể được phát biểu như sau: \\

Cho một  tập hữu hạn $N=\{1,\dots,n\}$, trọng số $c_j, \ j \in N$, và một tập $F$ là một tập con của $N$. Bài toán yêu cầu tìm một tập con với tổng trọng số nhỏ nhất : 
$$min_{S \subseteq F}\{\sum_{j \in S}c_j:S \in F\}$$
%Tìm cực tiểu hay cực đại của phiến hàm $$f(x)\rightarrow min(max), x \in D$$ trong đó $D$ là một tập hữu hạn các phần tử. Hàm $f(x)$ được gọi là hàm mục tiêu của bài toán. Mỗi phần tử $x\in D$ được gọi là một phương án của bài toán, tập $D$ gọi là tập các phương án của bài toán. Phương án $x^* \in D$ đem lại giá trị nhỏ nhất (lớn nhất) cho hàm được gọi là phương án tối ưu, khi đó $f^*=f(x^*)$ được gọi là giá trị tối ưu của bài toán.
\subsubsection{Bài toán thỏa mãn ràng buộc}
Một ràng buộc \cite{AIAMAB} là một quan hệ trên trên một tập các biến. Mỗi biến có một tập hữu hạn các giá trị có thể nhận gọi là miền giá trị. Một ràng buộc có thể được biểu diễn bằng một biểu thức toán học hoặc một bảng liệt kê các giá trị phù hợp cho các biến. 
Một \ac{CSP} bao gồm : \begin{enumerate}
\item Một tập các \textbf{biến} X.
\item Miền giá trị (một tập hữu hạn các giá trị) cho mỗi biến D.
\item Một tập hữu hạn các ràng buộc C.
\end{enumerate}  
Một trạng thái của bài toán được định nghĩa bởi một phép gán các giá trị cho tất cả các biến. Một trạng thái được gọi là lời giải khi nó thỏa mãn tất cả các ràng buộc trong $C$. Một vài bài toán \ac{CSP} còn yêu cầu tối ưu một hoặc nhiều hàm mục tiêu.  \\

Chúng tôi trình bày hai ví dụ điển hình cho bài toán thỏa mãn ràng buộc là bài toán N con hậu và bài toán phân bổ chương trình học.
\subsubsection{N con hậu (N-QUEEN)}
Bài toán yêu cầu xếp $n$ quân hậu trên bàn cờ vua $n\times n$ sao cho không có hai quân hậu bất kì nào ăn được nhau.

\paragraph{Mô hình toán học}
\subparagraph{Biến}
Gọi $X=\{x_1,\ldots,x_n\}$ với $x_i$ có giá trị là cột của con hậu hàng thứ $i$.
\subparagraph{Miền giá trị}
Miền giá trị của $x_i$ là $D(x_i)=\{1,\ldots,n\}, \ \forall i=1,2,\dots,n$\\[0.5cm]
\begin{minipage}{0.3\textwidth}
\includegraphics[width=\textwidth]{n-queen.png}
\end{minipage}
\begin{minipage}{0.6\textwidth}
VD: Với 4 con hậu được xếp như hình bên trạng thái của các biến sẽ là: $$x_1=2,x_2=4,x_3=1,x_4=3$$
\end{minipage}
\subparagraph{Các ràng buộc}
\begin{itemize}
\item Các con hậu không được ở trên cùng một cột.
$$ x_i \neq x_j, \ \forall i \neq j, \quad i,j \in \{1,\dots,n\} $$
\item Các con hậu không cùng trên một hàng chéo.
$$x_i-x_j \neq i-j , \ \forall i \neq j, \quad i,j \in \{1,\dots,n\}$$
$$x_j-x_i \neq i-j, \ \forall i \neq j, \quad i,j \in \{1,\dots,n\}$$
\end{itemize} 
\subsubsection{Bài toán phân bổ môn học (Balanced Academic Curriculum Problem) }
Bài toán phân bổ môn học \cite{csplib30} yêu cầu thiết kế một chương trình học, được định nghĩa bằng việc sắp xếp các môn vào các kì học sao cho thỏa mãn các quy định và cân bằng về số tín chỉ cũng như số môn giữa các học kỳ. Một chương trình học phải thỏa mãn các quy định sau:
\begin{itemize}
\item Một chương trình học định nghĩa bởi một tập các môn học và tập các mối quan hệ giữa chúng.
\item Số lượng kì : một chương trình học chỉ được phép kéo dài trong một số kì nhất định.
\item Định lượng : Mỗi môn học có một chỉ số tín chỉ khi mà hoàn thành lớp mỗi sinh viên nhận được tích lũy.
\item Lớp tiên quyết : Có một số môn cần có những lớp khác học trước.
\item Giới hạn tín chỉ : Trong một kì sinh viên không được học quá ít, hoặc quá nhiều tín chỉ.
\item Số lớp tối thiểu : Số lượng lớp tối thiểu trong một kì của sinh viên.
\item Số lớp tối đa : Số lượng lớp tối đa trong một kì của sinh viên.
\end{itemize}
Mục đích của vấn đề là xếp các môn vào các kì sao cho thỏa mãn tất cả các quy định trên và  chênh lệch số lượng tín chỉ trong các kì là nhỏ nhất.\paragraph{Mô hình toán học}
\subparagraph{Đầu vào}
\begin{itemize}
	\item $nPeriods$ là số lượng kì cần xếp lịch.
	\item $nCourses$  là số lượng môn cần xếp lịch.
	\item $prereq$ là một danh sách các phần tử có dạng $\langle i,j \rangle $ thể hiện môn $i$ cần phải được học trước môn $j$.
	\item $credit(j)$ là số lượng tín chỉ của môn $j$.
	\item $a$ là số lượng tín chỉ ít nhất trong một kì.
	\item $b$ là số lượng tín chỉ nhiều nhất trong một kì.
	\item $c$ là số lượng môn ít nhất trong một kì.
	\item $d$ là số lượng môn nhiều nhất trong một kì.
\end{itemize}
\subparagraph{Biến}
Biến quyết định mô hình hóa bài toán là $$X= \{ X_{ij}| \ i\in \{1,\dots,nPeriods\},j\in \{1,\dots,nCourses\}  \} $$

\subparagraph{Miền giá trị}
Miền giá trị của $X_{ij}$ là $D(X_{ij})=\{0,1\}$, trong đó :
\begin{itemize}
\item $X_{i,j}=1$ nếu lớp $j$ được đặt trong kì $i$.
\item $X_{i,j}=0$ nếu ngược lại. 
\end{itemize}
\subparagraph{Các ràng buộc}
Ta định nghĩa : $$load[i]=\sum_{j \in \{1,\dots,nCourses\} } credit(j) *X_{i,j}   ,\forall i \in \{1,\dots,nPeriods\}$$
\begin{itemize}
\item Ràng buộc cho biết mỗi môn chỉ được xếp trong đúng một học kì
$$   \sum_{i \in \{1,\dots,nPeriods\} } X_{ij}=1,\forall j \in\{1,\dots,nCourses\}  $$

\item Ràng buộc thể hiện điều kiện học phần học trước $$ \forall\langle i,j\rangle \in prereq, \ \forall k \in \{1,\dots,nPeriods\} $$
$$X_{kj} \leq \sum^{k-1}_{r=1} X_{ri} $$ 
\item Ràng buộc về giới hạn số tín chỉ trong một kì $$a \leq load[i] \leq b, \forall i \in \{1,\dots,nPeriods\}$$
\item Ràng buộc về giới hạn số lớp học trong một kì $$ \ c \leq \sum_{j \in \{1,\dots,nCourses\}} X_{ij} \leq d , \ \forall i \in \{1,\dots,nPeriods\} $$
\end{itemize}
\subsection{Ứng dụng}
Trong phần này chúng tôi trình bày một vài bài toán tối ưu hóa tổ hợp cụ thể. Những bài toán này đều là những bài toán thực tiễn được phát biểu dưới dạng bài toán tối ưu hóa tổ hợp, qua đó thể hiện được tính ứng dụng cao của bài toán tối ưu hóa tổ hợp trong môi trường thực tế.
\subsubsection{Lập thời khóa biểu}
Cho một tập môn học : $C=\{c_1,\ldots, c_n\}$ cần phải xếp vào các tiết học trong các ngày trong tuần. Mỗi môn học $c_i$ có $d(c_i)$ là số lượng tiết và $p(c_i)$ là giảng viên được yêu cầu dạy môn học. Mỗi ngày được chia thành 12 tiết bao gồm 6 tiết buổi sáng và 6 tiết buổi chiều. Bài toán yêu cầu xếp lịch cho tập các môn học $C$ sao cho thỏa mãn các ràng buộc : \begin{itemize}
\item Hai môn học bất kì thuộc cùng một giảng viên dạy thì không có thời gian dạy chồng lấp nhau.
\item Mỗi môn học chỉ được học trong một buổi sáng hoặc chiều.
\end{itemize}

\subsubsection{Phân công y tá}
\paragraph{Đầu vào}
Bài toán yêu cầu xếp lịch ca trực cho $n$ y tá trong $m$ ngày. Mỗi ngày có $k$ kíp trực khách nhau.  
\paragraph{Ràng buộc}
\subparagraph{Ràng buộc cứng}
\begin{itemize}
\item Mỗi y tá chỉ trực một ca trong ngày.
\item Mỗi y tá chỉ trực một số lượng thời gian nhất định.
\item Với một kíp số lượng lần trực của y tá không được vượt quá một đại lượng nhất định.
\item Mỗi y tá không có đợt nghỉ quá ngắn.
\item Số lượng ca trực liên tục của một y tá không được quá nhiều hoặc quá ít.
\item Các y tá không được trực quá trong các đợt cuối tuần.
\item Các y tá được đăng kí một số ngày họ được nghỉ.
\end{itemize}
\subparagraph{Ràng buộc mềm}
\begin{itemize}
\item Các y tá được phép yêu cầu nghỉ hoặc làm một số ca nào đó.
\item Bệnh viện yêu cầu số lượng y tá trong mỗi ca trực.
\end{itemize}

\subsubsection{Lập lộ trình vận tải}
Lớp bài toán lập lộ trình vận tải \cite{TUHTT} là một trọng những lớp bài toán tối ưu quan trọng trong ngành công nghiệp giao vận. Xét bài toán tổng quát được định nghĩa như sau:

Xét một mô hình vận tải gồm $m$ nhà cung ứng (hay còn gọi là điểm phát) và $n$ cửa hàng (điểm thu). Bài toán yêu cầu vận chuyển hàng hóa từ các  nhà cung ứng đến các cửa hàng sao cho chi phí di chuyển là nhỏ nhất.
\begin{itemize}
\item  $m$ nhà cung ứng.
\item  $n$ cửa hàng.
\item  $a_i$ lượng hàng nhà cung ứng $i$ cung cấp.
\item  $b_j$ lượng hàng cần nhập của cửa hàng $j$.
\item  $c_{ij}$ cước phí vận chuyển một đơn vị hàng từ nhà cung cấp $i$ đến cửa hàng $j$.
\end{itemize}
\begin {center}
\begin{tikzpicture}[
state/.style ={circle,draw}]
\node[state] (00) at (0,-1){$p_m$};
\node (-20) at (-2,-1){Cung cấp $a_m$};
\node[state] (50) at (5,-1){$q_n$};
\node (70) at (7,-1){Cần nhập $b_n$};
\node(01) at (0,0.5) {\ldots};
\node(51) at (5,0.5) {\ldots}; 
\node[state] (02) at (0,2) {$p_2$};
\node (-22) at (-2,2) {Cung cấp $a_2$};
\node [state] (52) at (5,2){$q_2$};
\node (72) at (7,2){Cần nhập $b_2$}; 
\node[state] (03) at (0,3)  {$p_1$}; 
\node (-23) at (-2,3)  {Cung cấp $a_1$}; 
\node[state] (53) at (5,3)  {$q_1$}; 
\node (73) at (7,3)  {Cần nhập $b_1$}; 
\node (04) at (0,4)  {Nhà cung ứng}; 
\node (54) at (5,4)  {Cửa hàng}; 
\node (22) at (3,-2)  {Cước phí vận chuyển $c_{ij}$}; 
\path [-] (00) edge node[above] {} (50);
\path [-] (00) edge node[above] {} (52);
\path [-] (00) edge node[above] {} (53);
\path [-] (02) edge node[above] {} (50);
\path [-] (02) edge node[above] {$x_{ij}$} (52);
\path [-] (02) edge node[above] {} (53);
\path [-] (03) edge node[above] {} (50);
\path [-] (03) edge node[above] {} (52);
\path [-] (03) edge node[above] {} (53);
\end{tikzpicture}
\end{center}
\section{Các hướng tiếp cận giải bài toán tối ưu hóa tổ hợp}
\label{section:cbs}
\subsection{Thuật toán giải đúng}
Trong phần này chúng tôi trình bày một vài phương pháp phổ biến được sử dụng giải đúng bài toán tối ưu hóa tổ hợp. Ngoài các phương pháp được nêu dưới đây còn rất nhiều các phương pháp khác được sử dụng để giải bài toán tối ưu hóa tổ hợp.
\subsubsection{Quy hoạch động (Dynamic Programming)}
Quy hoạch động \cite{ITA} là một kĩ thuật được thiết kế khá vạn năng để phát triển cho nhiều lớp bài toán khác nhau. Kỹ thuật này là một trong những công cụ mạnh để thiết kế thuật toán giải bài toán tối ưu hóa.\\

Giống như chia để trị\footnote{Chia để trị là một thuật toán cơ bản trong ngành công nghệ thông tin, thuật toán thực hiện giải quyết một bài toán bằng việc giải các bài toán con của nó , sau đó tổng hợp các lời giải bài toán con thành lời giải bài toán cha. Việc tổng hợp này thường được thực hiện một cách đệ quy.}, quy hoạch động giải bài toán bằng việc tổng hợp lời giải từ các bài toán con. Với quy hoạch động các bài toán con được phép chồng lên nhau, tức là có thể có hai bài toán cha có chung một bài toán con. Với mỗi bài toán con được giải chúng được lưu lại vào một bảng để tránh việc lặp lại tính toán. 

 Các bước để phát triển một thuật toán quy hoạch động là:
\begin{itemize}
\item Biểu diễn cấu trúc của một lời giải  tối ưu cho bài toán đầu vào.
\item Biểu diễn giá trị của một lời giải tối ưu cho bài toán đầu vào.
\item Tính toán các lời giải tối ưu của các bài toán con, theo thứ tự từ dưới lên.
\item Xây dựng lời giải tối ưu từ những thông tin đã tính toán.
\end{itemize}
 
\subsubsection{Quy hoạch ràng buộc (Contraint Programming)}
Quy hoạch ràng buộc \cite{HCP} cũng là một phương pháp giải đúng bài toán tối ưu hóa tổ hợp. Chúng ta có thể xây dựng chiến lược tìm kiếm trong quy hoạch ràng buộc, đôi khi ta có thể thêm các nhánh cận để thuật toán hiệu quả hơn. Hai thành phần chính trong quy hoạch ràng buộc là: \begin{itemize}
\item Loại bỏ giá trị thừa.
\item Tìm kiếm quay lui.
\end{itemize}

Giải thuật tìm kiếm quay lui là giải thuật tìm kiếm phổ biến nhất được sử dụng trong bài toán CSP. 
\begin{itemize}
\item Dựa trên giải thuật tìm kiếm theo chiều sâu.
\item Mỗi lần gán, chỉ gán giá trị cho một biến.
\item Sau mỗi phép gán giá trị cho một biến nào đó, kiểm tra các ràng buộc có được thỏa mãn bới các biến đã được gán giá trị cho đến thời điểm hiện tại. Quay lui nếu có vi phạm ràng buộc. 
\end{itemize}
Có hai yêu tố chính ảnh hưởng đến lời giải cúa phương pháp quay lui là:
\begin{itemize}
\item Thứ tự được xét của các biến.
\item Với mỗi biến thứ tự được xét của các giá trị.

\end{itemize}

Giải thuật kiểm tra tiến là một giải thuật điểm hình về loại bỏ giá trị thừa. Mục đích của kiểm tra tiến là tránh các thất bại trong tìm kiếm bằng việc kiểm tra trước các ràng buộc. Ý tưởng của thuật toán như sau:
\begin{itemize}
\item Ở mỗi bước gán giá trị, thực hiện theo dõi các giá trị hợp lệ (có thể được gán) đối với các biến chưa được gán giá trị. 
\item Loại bỏ hướng tìm kiếm khi bất kì một biến chưa được gán giá trị mà không còn giá trị hợp lệ.
\end{itemize}

\subsubsection{Quy hoạch nguyên tuyến tính (Linear Integer Programming)}
Giả sử ta có một hàm $$max\{cx : Ax \leq b, x \geq 0\}$$ với $A$ là một ma trận $m$ hàng $n$ cột, $c$ là một vector hàng gồm $n$ phần tử, $b$ là một vector cột gồm $m$ phần tử và $x$ là một vector cột gồm $n$ biến số chưa biết.\\

 Với tất cả các biến phải là giá trị nguyên ta có mô hình bài toán quy hoạch nguyên tuyến tính\cite{IP} :
$$max \ cx$$
$$Ax \leq b$$
$$x \geq 0 \ \text{và nguyên}$$
%$$f(x_1,x_2,\ldots, x_n)=\sum_{j=1..n}c_jx_j \rightarrow max(min)$$
%$$g_i(x)=\sum_{j=1..n}a_{ij}x_j-b_i=0, i=1,2,\ldots, m_1$$
%$$h_i(x)=\sum_{j=1\ldots n} a_{ij}x_j-b_i \leq 0, i=m_1+1, \ldots, m$$
%$$x_j -\text{nguyên}, j=1,2,\ldots,n$$

Các thuật toán thường được sử dụng giải quyết bài toán quy hoạch nguyên tuyến tính là: 
\begin{itemize}
\item Phương pháp nhánh cận.
\item Cutting plane.
\item Branch and cut.
\end{itemize}
\subsection{Thuật toán giải gần đúng}
Thuật toán giải đúng luôn cho lời giải chính xác nhưng bù lại có độ phức tạp tính toán tương đối cao thường là hàm mũ, vì vậy với những bài toán có kích thước đầu vào lớn thì việc sử dụng thuật toán giải đúng dường như là không thể. Trong khi đó các thuật toán giải gần đúng mặc dù không cho lời giải chính xác tuyệt đối nhưng thời gian thực thi lại hoàn toàn có thể chấp nhận được. Chính vì vậy, hiện nay với những bài toán tối ưu hóa tổ hợp có kích thước đầu vào lớn các thuật giải gần đúng thường được sử dụng. Trong phần này chúng tôi trình bày một vài các thuật toán gần đúng điển hình để giải bài toán tối ưu hóa tổ hợp đó là : thuật toán tham lam, thuật toán tìm kiếm cục bộ và thuật toán di truyền. Ngoài ra còn rất nhiều thuật toán gần đúng khác được sử dụng để giải bài toán tối ưu hóa tổ hợp.
\subsubsection{Thuật toán tham lam (Greedy Algorithms)}
Giải thuật cho các bài toán tối ưu hóa thường đi từng bước một, với mỗi bước có các tập lựa chọn. Cho nhiều vấn đề, quy hoạch động thường được sử dụng để xác định lựa chọn tốt nhất. Thuật toán tham lam \cite{ITA} luôn luôn chọn một lựa chọn tốt nhất ở bước hiện tại. Việc lựa chọn này như  đi theo một tối ưu cục bộ và ta luôn hi vọng nó sẽ dẫn đến tối ưu toàn cục. Chính vì vậy, thuật toán tham lam không phải lúc nào cũng đưa ra được lời giải tối ưu. 

Thuật toán tham lam là một phương pháp khá mạnh và làm việc tốt cho các bài toán với kích thước lớn. 


%Thuật toán tham lam là một hướng tiếp cận cho lời giải gần đúng. Với một trạng thái hiện tại ta đưa ngay ra quyết định từ những thông tin của trạng thái hiện tại mà không phải xem xét cá bước đi trong quá khứ. Chính vì vậy thời gian thực hiện thuật toán nhanh nhưng thường cho kết quả không chính xác tuyệt đối. Sơ đồ hoạt động của thuật toán gồm các bước sau:
%\begin{enumerate}
%\item Lặp:
%\begin{enumerate}
%
%\item Chọn phần ứng cử viên có triển vọng nhất vào lời giải hiện có.
%\item Kiểm tra tính chấp nhận được của lời giải bộ phận.
%
%\end{enumerate}
%\item Kiểm tra tính chấp nhận được của lời giải toàn cục. \cite{DAA}
%\end{enumerate}
\subsubsection{Thuật toán tìm kiếm cục bộ (Local Search Algorithms)}
Tìm kiếm cục bộ \cite{MTH} là một trong các mô hình được sử dụng để giải quyết các bài toán CSP. Nó cung cấp cơ sở cho một vài phương pháp thành công và linh hoạt nhất trong việc giải các bài toán lớn và khó bắt nguồn từ nhiều ứng dụng thực tế. \\

Ý tưởng của tìm kiếm cục bộ là : bắt đầu từ một lời giải được sinh ngẫu nhiên hoặc heuristic. Những lời giải này có thể là tối ưu cục bộ hoặc chưa hoàn chỉnh \dots. Thuật toán cải thiện các lời giải này từng bước bằng cách tạo ra các thay đổi nhỏ trong nó ở mỗi bước. Các phương thức tìm kiếm cục bộ khác nhau khác nhau trong cách cải tiến lời giải đạt được. Thuật toán sẽ dừng lại khi không thể cải tiến thêm được lời giải.

Một số phương pháp tìm kiếm cục bộ sử dụng yếu tố ngẫu nhiên để đảm bảo việc tìm kiếm không bị dừng lại ở tối ưu cục bộ. Các phương pháp đáng chú ý như stochastic hill-climbing, simulated annealing, tabu search, dynamic local search \dots. Lớp các phương pháp như vậy được gọi là \textit{metaheuristics}.


%Ý tưởng của thuật toán tìm kiếm cục bộ là cải thiện lời giải qua từng bược lặp bằng việc di chuyển qua một láng giềng của lời giải. Láng giềng của một lời giải là lời giải đó sau khi một hoặc một vài biến đã được cập nhật giá trị mới. Vì vậy, một bước di chuyển tương đương với việc cập nhật một hoặc một vài giá trị mới cho các biến. Tất nhiên ta phải có một hàm dùng để đánh giá chất lượng lời giải (vd: hàm số lượng ràng buộc đang bị vi phạm ở thời điểm hiện tại). 

\subsubsection{Thuật toán di truyền (Genetic Algorithms)}
Thuật toán di truyền \cite{MTH} được phát triển bởi J. Holland vào năm 1970s. Ý tưởng của thuật toán di truyền dựa trên thuyết tiến hóa của Darwin về cơ chế tiến hóa của quần thể trong tự nhiên. Các toán tử thường được sử dụng trong thuật toán di truyền là:
\begin{itemize}
\item Toán tử sinh sản: chọn lọc, tái sinh.
\item Toán tử lai ghép.
\item Toán tử đột biến.
\end{itemize} 
Các bước thực hiện cơ bản của thuật toán di truyền như sau:
\begin{enumerate}
\item Khởi tạo quần thể ban đầu gồm các nhiễm sắc thể.
\item Lặp:
\begin{enumerate}

\item Xác định giá trị hàm mục tiêu của các nhiễm sắc thể.
\item Tạo nhiễm sắc thể mới bằng toán tử di truyền.
\item Chọn lọc tự nhiên.

\end{enumerate}
\end{enumerate}
\section{Công nghệ ofbiz}
\label{section:ofbiz}
Apache Ofbiz \cite{AOW} là một công nghệ trên nền tảng \ac{ERP} cung cấp các tính năng phong phú cho doanh nghiệp như thương mại điện tử, quản lý sản xuất,  quản lý dự án bán lẻ và thương mại. Ofbiz có thể sử dụng trong các tổ chức trong tất cả các ngành và mọi quy mô ở bất kì nước nào. Ofbiz là framework mã nguồn mở nên các nhà sản xuất hoàn toàn có thể mở rộng và phát triển để thực hiện các tính năng riêng của từng sản phẩm. \\

Ofbiz sử dụng ngôn ngữ lập trình Java xây dựng ứng dụng Web. Kiến trúc ofbiz gồm 3 tầng: 
\begin{itemize}
\item \textbf{Tầng dữ liệu}  là tầng chịu trách nhiệm truy cập dữ liệu từ cơ sở dữ liệu, lưu trữ và cung cấp các giao diện truy cập cho tầng nghiệp vụ.

\item \textbf{Tầng nghiệp vụ} cung cấp các service cho người sử dụng. Có nhiều loại service trong tầng này: Java methods, \ac{SOAP}, simple services, workflow, etc. Service engine sẽ chịu trách nhiệm quản lý transaction và bảo mật.
\item \textbf{Tầng trình điễn} là tầng trên cùng của ứng dụng cung cấp các giao diện người dùng. Ofbiz sử dụng các khái niệm "screen" để trình bày các trang web. Một giao diện người dùng có thể được ghép lại bởi nhiều screen. Mỗi screen tương ứng với một component. Component có thể được viết bằng \ac{JSP} hoặc \ac{FTL}. 
\end{itemize}

\chapter{Bài toán lập lộ trình giao hàng  kết hợp một xe tải với  một thiết bị bay cùng các nghiên cứu liên quan }
Trong chương này chúng tôi trình bày về bài toán lập lộ trình giao hàng kết hợp một xe tải với một thiết bị bay không người lái cùng hai thuật toán \ac{GRASP} và TSP-LS. Cả hai thuật toán đều xây dựng lời giải cho bài toán yêu cầu từ kết quả của bài toán người du lịch tương ứng. Trong phần  \ref{section:tspd} chúng tôi mô tả bài toán lập lộ trình giao hàng kết hợp một xe tải với một thiết bị bay, các yêu cầu, ràng buộc và mô hình quy hoạch nguyên bộ phận. Trong phần \ref{section:grasp} và \ref{section:tsp-ls}, chúng tôi trình bày cụ thể về thuật toán \ac{GRASP} và TSP-LS bao gồm ý tưởng và mã giải. Các tài liệu tham khảo sử dụng trong phần này bao gồm \cite{main}, \cite{bahiwww} \cite{12}, \cite{13}, \cite{14}, \cite{15}, \cite{16}, \cite{17}, \cite{18}, \cite{19}, \cite{21}.
\section{Bài toán lập lộ trình vận tải giao hàng kết hợp xe tải và một thiết bị bay}
\label{section:tspd}
\subsection{Mô tả bài toán}
Trong bài toán giao hàng truyền thống, xe tải nhận hàng từ một điểm sau đó đi giao hàng ở tất cả các cửa hàng mỗi cửa hàng đúng một lần. Mô hình này được gọi là bài toán người du lịch. Nhưng gần đây, dưới sự phát triển mạnh mẽ của phương tiện bay không người lái một phương thức giao hàng mới đã được ra đời là \ac{TSPD} trong đó drone tham gia giao hàng cũng với xe tải. Dưới đây là bốn lợi ích nổi bật của drone \cite{main} :
\begin{itemize}
\item Drone không cần người lái.
\item Drone là một phương tiện bay.
\item Drone bay giao hàng nhanh hơn xe tải.
\item Drone tốn ít chi phí hơn xe tải.
\end{itemize}

Ngoài những ưu điểm drone cũng có những điểm hạn chế:

\begin{itemize}
\item Drone có giới hạn năng lượng, chỉ bay được một khoảng nhất định sau đó nó phải sạc điện.
\item Drone chỉ mang được giới hạn khối lượng.
\end{itemize}

Ngược lại với drone, xe tải là phương tiện có thể chở nhiều hàng hóa và có nhiều năng lượng, có thể chạy quãng đường dài. Dựa trên những ưu nhược điểm của hai phương tiện này một phương thức giao hàng được đề xuất có tên gọi là "last mile delivery with drone" \cite{bahiwww}. Trong phương thức giao hàng này, xe tải mang toàn bộ kiện hàng mà nó phải giao đi. Sau đó xe tải vận chuyển drone đến gần địa điểm khách hàng và cho phép drone phục vụ khách hàng trong phạm vị nó hoạt động được. Trong lúc đó xe tải vẫn tiếp tục thực hiện tiếp lộ trình của mình.  Drone phục vụ khách hàng xong sẽ quay lại xe tải ở một điểm mới khác với điểm nó bay lên. \\


Cho một danh sách khách hàng cần phục vụ, để giao hàng drone được thả ở một điểm và quay lại ở một điểm khác. Mỗi khách hàng được phục vụ chỉ bởi drone hoặc xe tải. Hai phương tiện xuất phát cùng nhau từ kho hàng và lại quay về kho hàng khi giao hàng xong. Chúng ta gọi \ac{DD} gồm 3 thành phần $\langle i,j,k \rangle$ trong đó $i$ là điểm bay của drone, $j$ là điểm khách hàng mà drone giao hàng tới và $k$ là điểm mà drone quay trở lại xe tải. Các quy định về điểm bay, điểm giao hàng và điểm đón như sau:
\begin{itemize}
\item Điểm bay của drone (launch node) là điểm mà drone rời khỏi xe tải đi giao hàng. Điểm bay của drone bắt buộc phải là một điểm giao hàng hoặc điểm kho hàng. 
\item Điểm giao hàng (drone node) là một vị trí cần giao hàng. Không phải tất cả các điểm đều có thể trở thành điểm giao hàng của drone vì có những điểm ngoài phạm vị phục vụ được của drone.
\item Điểm hạ cánh (rendezvous node) hay còn gọi là điểm đón là điểm mà drone quay trở lại xe tải. Tất nhiên hai phương tiện có thể phải chờ nhau tại điểm này.
\end{itemize}
Gọi  \ac{TD} là một chuỗi lộ trình qua các điểm $\langle e_0,e_1,..,e_k \rangle $ với $e_0$ và $e_k$ là điểm kho.
Drone có một mức năng lượng nhất định vì vậy nó chỉ bay được liên tục trong một khoảng cách nhất định mà drone có thể bay (endurance), trong đồ án này chúng tôi gọi là mức chịu đựng. Một \ac{DD} gọi là chấp nhận được nếu quãng đường từ điểm bay qua điểm giao hàng về điểm đón nhỏ hơn mức chịu đựng của drone. Cả xe tải và drone đều có một đại lượng là chi phí vận chuyển. Trong thực tế, chi phí vận chuyển của drone thường thấp hơn nhiều so với xe tải bởi vì trọng lượng của nó nhỏ hơn và cũng tốn ít năng lượng hơn.


\subsection{Các nghiên cứu liên quan}
Trong phần này chúng tôi trình bày các nghiên cứu liên quan đến bài toán vận tải với sự tham gia của xe tải và drone.\\

Năm 2015, Murray và Chu \cite{12} giới thiệu bài toán \ac{FSTSP}. Một mô hình \ac{MIP} và một heuristic cũng được đề xuất. Heuristic dựa trên ý tưởng "xe tải trước, drone sau" trong đó đầu tiên họ xây dựng lộ trình cho xe tải bằng việc giải bài toán \ac{TSP} và sau đó lặp đi lặp lại việc sử dụng thủ tục $relocation$ để giảm hàm mục tiêu. Thực chất thủ tục $relocation$ kiểm tra mỗi điểm thuộc hành trình TSP và thử chuyển chúng thành các điểm được giao hàng bởi drone. Khi một điểm đã được chuyển thành drone nó sẽ không bao giờ được kiểm tra lại nữa. Mặt khác các điểm giao hàng có thể thay đổi vị trí trong lộ trình nếu việc đặt vào một vị trí mới có thể làm giảm chi phí của lời giải. \\

Agatz \cite{13} trong một ấn phẩm không chính thức nghiên cứu một vấn đề hơi khác gọi là Traveling Salesman Problem with Drone (TSP-D), trong đó drone phải di theo mạng lưới đường bộ như chiếc xe tải. Hơn nữa, trong bài toán này drone phải bay lên và hạ cánh ở cùng vị trí, trong khi với \ac{FSTSP} điều này bị cấm. Bài toán cũng  được giải bởi heuristic "Xe tải trước, Drone sau" trong đó lộ trình của drone được xây dựng dựa trên tìm kiếm cục bộ hoặc quy hoạch động. Gần đây hơn, Ponza \cite{14} kế thừa từ nghiên cứu của Murray và Chu \cite{12}, đề xuất một nâng cấp của mô hình \ac{MIP} cho bài toán \ac{FSTSP} và giải quyết bằng một phương pháp heuristic dựa trên Simulated Annealing \footnote{Simulated Annealing là một phương pháp metaheuristic}.

Tất cả các nghiên cứu được nhắc đến trên đều có hàm mục tiêu là thời gian xe tải hoàn thành lộ trình và quay trở lại điểm kho, tối ưu hàm mục tiêu này hướng đến tăng chất lượng phục vụ \cite{16}. Gần đây một nghiên cứu bởi Mathew \cite{19} cho một vấn đề được gọi là \ac{HDP}. Tuy nhiên, không giống những bài toán được nghiên cứu trước đấy bài toán được mô hình trên một đường phố thực tế mà ở đó xe tải không được phép giao hàng đến khách hàng. Thay vào đó, tại mỗi điểm cuối của cạnh, xe tải có thể thả một drone đi phục vụ khách hàng. Bằng cách này, bài toán có thể được chuyển đổi thuận lợi sang bài toán  \ac{GTSP} \cite{21}.\\

Kế thừa nghiên cứu của Murray và Chu \cite{12} và nhận thấy trong các mô hình vận tải chi phí vận chuyển mới thường là quan trọng (xem \cite{17} và \cite{18}). Tác giả Hà Quang Minh và cộng sự đề xuất mô hình min-cost TSPD \cite{main} với các đặc điểm: \begin{itemize}
\item Xe tải và drone có thể đi cùng nhau, cả hai phương tiện đều có thể phục vụ các điểm khách hàng.
\item Drone phải phải bay lên từ một điểm khách hàng và quay lại xe tải ở một điểm khác với điểm nó bay lên.
\item Xe tải không thể quay lại điểm mà nó đã đi qua để đón drone.
\end{itemize}
Và quan trọng hơn cả hàm mục tiêu của bài toán là tối thiểu chi phí vận chuyển của cả hai phương tiện. Đây cũng chính là bài toán được chúng tôi trình bày và là nội dung chính của chương này. 

Bởi vì bài toán sẽ trở thành bài toán TSP khi sức chịu đựng drone giảm dần về không vì vậy bài toán là NP-hard. 
\subsection{Mô hình bài toán min-cost TSPD}
Mô hình bài toán được xây dựng trừu tượng dựa trên mô hình đồ thị $G=(V,A), V=\{0,1,...,n,n+1\}$ với đỉnh $0$ và $n+1$ tương ứng là kho. $N$ khách hàng được giao tương ứng với tập $N$ điểm tương ứng là đỉnh $1$ đến đỉnh $n$ trong đồ thị $G$. Gọi $d_{ij}$ và $d'_{ij}$ là khoảng cách từ đỉnh $i$ đến đỉnh $j$ theo xe tải và drone. Tiếp đó $C_1$ và $C_2$ là chi phí phải trả cho xe tải và drone khi đi một đơn vị độ dài.  
Gọi $s$ là một tập các đỉnh theo thứ tự $s=\langle s_1,s_2,..,s_t \rangle , s_i \in V, i=1,..,t$ hay gọi là chuỗi lộ trình chúng ta định nghĩa các khái niệm sau:

\begin{itemize}
\item[-] $V(s) \subseteq V$ là danh sách các đỉnh có trong $s$.
\item[-] $pos(i,s)$ vị trí của đỉnh $i$ trong $s$.
\item[-] $next_s(i)$ đỉnh tiếp theo của $i$ trong $s$.
\item[-] $prev_s(i)$ đỉnh trước của $i$ trong $s$.
\item[-] $first(s)$ đỉnh bắt đầu trong $s$.
\item[-] $last(s)$ đỉnh kết thúc trong $s$.
\item[-] $s[i]$ đỉnh thứ $i$ trong $s$.
\item[-] $size(s)$ số lượng đỉnh trong $s$.
\item[-] $sub(i,j,s) \ \text{với} \ i,j \in s $ là một chuỗi lộ trình con của $s$.
\item[-] $A(s)=\{(i,next_s(i))| \ i \in V(s)\setminus last(s)\}$ là tập cảnh thuộc đường đi của $s$.

\end{itemize}

Một \ac{DD} là một tập $\langle i,j,k\rangle \quad i,j,k \in V, i \neq j, j \neq k,k \neq i, d'_{ij}+d'_{jk} \leq \epsilon $, với $\epsilon $ là một hằng số thể hiện quãng đường lớn nhất mà drone có thể bay được (sức chịu đựng của drone), $\Delta$ là thời gian chờ đợi lớn nhất của cả hai phương tiện. Tất cả các \ac{DD} thỏa mãn trên đồ thị G là tập $$P=\{ \langle i,j,k \rangle : i,j,k \in V, i \neq j, j \neq k,k  \neq i, d'_{ij}+d'_{jk} \leq \epsilon,|d_{i\rightarrow k}-(d'_{ij}+d'_{jk})| \leq \Delta  \}$$
Một lời giải của bài toán min-cost TSPD bao gồm 2 thành phần:
\begin{itemize}
\item Một \ac{TD} là một chuỗi lộ trình qua các điểm $\langle e_0,e_1,..,e_k \rangle $ với $e_0=0$ và $e_k=n+1$ $0$ và $n+1$ là điểm kho, $e_i \neq e_j , \forall i \neq j$
\item Một tập $DDs=\{DD | DD \subseteq P \}$
\end{itemize} 
Hình \ref{tsptspd} mô tả một ví dụ về lời giải cho bài toán min-cost TSPD.
\begin{figure}[H]
\begin{subfigure}[c]{1\textwidth}
\centering
\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw},state2/.style={rectangle , draw}]
\node[state2] (1) at (0,0){};
\node[state] (2) at (4,1){6};
\node[state] (3) at (6,2){3};
\node[state] (4) at (5,8){5};
\node[state] (5) at (0,10){2};

\node[state] (6) at (3,4){1};
\node[state] (7) at (2,3){4};
\path [->] (1) edge node[above] {225} (2);
\path [->] (2) edge node[above] {175} (3);
\path [->] (3) edge node[right] {300} (4);
\path [->] (4) edge node[right] {250} (5);
\path [->] (5) edge node[right] {300} (6);
\path [->] (6) edge node[left] {50} (7);
\path [->] (7) edge node[right] {200} (1);
\end{tikzpicture}
\caption{Một hành trình người du lịch}
\label{tsptour}
\end{subfigure}
\begin{subfigure}{1\textwidth}
\centering
\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw},state2/.style={rectangle , draw}]
\node[state2] (1) at (0,0){  };
\node[state] (2) at (4,1){6};
\node[state] (3) at (6,2){3};
\node[state] (4) at (5,8){5};
\node[state] (5) at (0,10){2};

\node[state] (6) at (3,4){1};
\node[state] (7) at (2,3){4};
\path [->] (1) edge node[right] {200} (7);
\path [->] (7) edge node[left] {50} (6);
\path [->] (6) edge node[right] {300} (5);
\path [->] (5) edge node[left] {400} (1);

\path [->][dashed] (4) edge node[above] {9.0} (5);
\path [->][dashed] (6) edge node[right] {10} (4);
\path [->][dashed] (3) edge node[above] {8.2} (6);
\path [->][dashed] (7) edge node[above] {9.0} (3);
\path [->][dashed] (2) edge node[above] {6.4} (7);
\path [->][dashed] (1) edge node[above] {8} (2);

\end{tikzpicture}
\caption{Một hành trình TSPD}
\label{tspdtour}
\end{subfigure}
\caption{Lộ trình bài toán TSP và lộ trình bài toán TSPD tương ứng \cite{main}}\label{tsptspd}
\end{figure}
\subsection{Ràng buộc}
Một lời giải của bài toán min-cost \ac{TSPD} phải đảm bảo những ràng buộc sau đây.
\begin{itemize}
\item[(A)]  Mỗi khách hàng luôn phải được phục vụ bởi xe tải hoặc drone. 
\begin{equation} \label{eqn:A}
\forall e \in N: e \in TD \ or \ \exists \langle i,e,k \rangle \in DDs.
\end{equation}
\item[(B)]Một khách hàng chỉ được phục vụ duy nhất bởi một drone.
\begin{equation}\label{eqn:B}
\forall \langle i,j,k\rangle,\langle i',j',k'\rangle \in DD: j \neq j'
\end{equation}
\item[(C)] Mỗi một DD phải thỏa mãn với TD
\begin{equation}\label{eqn:C}
\forall \langle i,j,k \rangle \in DDs:j \not \in TD,i \in TD,k \in TD,pos(i,TD)<pos(k,TD)
\end{equation}
\item[(D)] Luôn luôn chỉ tồn tại một drone tải một thời điểm.
\begin{equation}\label{eqn:D}
\forall \langle i,.,k \rangle \in DD, \forall e \in sub(i,k,TD), \forall \langle i',j',k'\rangle \in DD: e \neq i'
\end{equation}
\end{itemize}
\subsection{Hàm mục tiêu}
\subsubsection{Một vài khái niệm}
\begin{itemize}
\item $cost(i,j,k)=C_2(d'_{ij}+d'_{jk}) \ $ $\langle i,j,k \rangle \in P$: chi phí của một \ac{DD}.
\item $cost(TD)=\sum(i,j) \in A(TD): C_1d_{ij}$: chi phí của một \ac{TD}.
\item $cost(DDs)=\sum \langle i,j,k \rangle \in DD: cost(i,j,k)$: chi phí của tất cả các \ac{DD} trong lời giải.
\item $cost(TD,DD)=cost(TD)+cost(DD)$: chi phí của lời giải.
\item $cost(sub(i,k,s))$ có giá trị là chi phí của cả xe tải và drone trong chuỗi lộ trình $s$.
\end{itemize}
\textbf{Hàm mục tiêu của bài toán} là tối thiểu tổng chi phí của lời giải.
\subsection{Mô hình Mixed Integer Programming }
Bài toán sẽ được trình bày cụ thể trong phần này bởi mô hình quy hoạch nguyên bộ phận.
\subsubsection{Biến}
Gọi $x_{ij} \in {0,1}$ với $i \in V_L= \{0,1,..,n\}, j \in V_R= \{1,2,..,n+1\}$ biểu diễn \ac{TD}, với $x_{ij}=1$ nghĩa là xe tải đi từ điểm $i$ đến điểm $j$.\\

Gọi $y_{ijk} \in {0,1}$ biểu diễn \ac{DD} với $y_{ijk}=1$ nếu $\langle i,j,k \rangle$ là một \ac{DD}.

Ta định nghĩa $p_{ij} \in {0,1}$ có giá trị bằng 1 nếu điểm $i$ được xe tải đến trước điểm $j$ $i \neq j$. Vì vậy ta khởi tạo $p_{0j}=1, \ \forall j \in N$ để yêu cầu xe tải bắt buộc phải xuất phát từ điểm kho. \\

Gọi $u_i, 0\leq u_i \leq n+1$ là vị trí của điểm $i, (i \in V)$ trong lộ trình của xe tải.
\subsubsection{Mô hình quy hoạch nguyên} 
\begin{center}

\begin{equation} \label{eqn:1}
\text{Min}\  C_1 \sum_{i\in V_L} \sum_{\substack{j \in V_R,\\ i\neq j}}d_{ij}x_{ij}+C_2\sum_{i\in V_L} \sum_{\substack{j\in N,\\i \neq j }} \sum_{\substack{k \in V_R,\\ \langle i,j,k \rangle \in P}}(d'_{ij}+d'_{jk})y_{ijk}  
\end{equation}
\begin{equation}\label{eqn:2}
 \sum_{\substack{i \in V_L, \\i \neq j}}x_{ij}+\sum_{\substack{i \in V_L,\\i \neq j}}\sum_{\substack{k \in V_R,\\\langle i,j,k \rangle \in P}}y_{ijk}=1 \ \forall j \in N
\end{equation}
\begin{equation}\label{eqn:3}
\sum_{j \in V_R} x_{0j}=1
\end{equation}
\begin{equation}\label{eqn:4}
\sum_{i \in V_L}x_{i,n+1}=1
\end{equation}
\begin{equation}\label{eqn:5}
u_i-u_j+1 \leq (n+2)(1-x_{ij}) \ \forall i \in V_L, j \in \{V_R:i \neq j\}
\end{equation}
\begin{equation}\label{eqn:6}
\sum_{\substack{i \in V_L, \\ i \neq j}} x_{ij}=\sum_{\substack{k \in V_R,\\k \neq j}} \forall j \in N
\end{equation}
\begin{equation}\label{eqn:7}
2y_{ijk} \leq \sum_{\substack{h \in V_L, \\ h \neq i}} x_{hi} +\sum_{\substack{ l \in N,\\ l \neq k}} x_{lk}, \ \forall i \in N, j \in \{N:i \neq j\},k \in \{V_R:\langle i,j,k \rangle \in P\}
\end{equation}
\begin{equation}\label{eqn:8}
y_{0jk} \leq \sum_{\substack{h \in V_L \\ h \neq k\\ h \neq j}} x_{hk} \ j\in N,k \in \{V_R:\langle 0,j,k \rangle \in P\}
\end{equation}
\begin{equation}\label{eqn:9}
u_k-u_i \geq 1-(n+2)(1- \sum_{\substack{j \in N \\ 
\langle i,j,k \rangle  \in P}} y_{ijk}) \ \forall i \in V_L,k \in {V_R:k \neq i}
\end{equation}
\begin{equation}\label{eqn:10}
\sum_{\substack{j \in N \\ j \neq i}} \sum_{\substack{k \in V_R \\ \langle i,j,k \rangle \in P}} y_{ijk} \leq 1 \ \forall i \in V_L
\end{equation}
\begin{equation}\label{eqn:11}
\sum_{\substack{i \in V_L \\  i \neq k}} \sum_{\substack{j \in N \\ \langle i,j,k \rangle \in P}} y_{ijk} \leq 1 \quad \forall k \in V_R
\end{equation}
\begin{equation}\label{eqn:12}
u_i-u_j \geq 1-(n-2)p_{ij}-M(2-\sum_{\substack{h\in V_L \\ h \neq i}}x_{hi}-\sum_{\substack{k\in N \\ k \neq j}}x_{kj}) \quad \forall i \in N, j\in \{V_R:j \neq i\}
\end{equation}
\begin{equation}\label{eqn:13}
u_i-u_j \leq -1+(n+2)(1-p_{ij})+M(2-\sum_{\substack{h\in V_L \\ h \neq i}}x_{hi}-\sum_{\substack{k\in N \\ k \neq j}}x_{kj}) \quad \forall i \in N, j\in \{V_R:j \neq i\}
\end{equation}
\begin{equation}\label{eqn:14}
u_0-u_j \geq 1-(n-2)p_{0j}-M(1-\sum_{\substack{k\in N \\ k \neq j}}x_{kj}) \quad \forall j\in V_R
\end{equation}
\begin{equation}\label{eqn:15}
u_0-u_j \leq -1+(n+2)(1-p_{0j})+M(1-\sum_{\substack{k\in N \\ k \neq j}}x_{kj}) \quad \forall j\in V_R
\end{equation}
\begin{equation}\label{eqn:16}
\begin{array}{l}
u_l \geq u_k-M(3-\sum_{\substack{j \in N \\ j \neq i \\ \langle i,j,k \rangle \in P}}y_{ijk}-\sum_{\substack{m \in N \\ m \neq i \\ m \neq k \\ m \neq l}}\sum_{\substack{n \in V_R\\n \neq i \\ n \neq k \\ \langle l,m,n \rangle  \in P}}y_{lmn}-p_{il}) \\ \quad \forall i \in V_L,k \in \{V_R:k \neq i\},l \in \{N:l \neq i,l\neq k\}

\end{array}
\end{equation}
\end{center}
Hàm mục tiêu là tối ưu tổng chi phí \eqref{eqn:1}.
Các ràng buộc trong mô hình quy hoạch nguyên được giải thích như sau:
\begin{itemize}
\item[•] Ràng buộc \eqref{eqn:2} đảm bảo mỗi một khách hàng chỉ được giao một lần bằng drone hoặc xe tải \eqref{eqn:A}.
\item[•] Ràng buộc \eqref{eqn:3}, \eqref{eqn:4} đảm bảo xe tải luôn xuất phát từ điểm kho.
\item[•] Ràng buộc \eqref{eqn:5} đảm bảo cho một chuỗi lộ trình thỏa mãn yêu cầu.
\item[•] Ràng buộc \eqref{eqn:6} đảm bảo xe tải đến và đi tại mọi điểm khách hàng mà nó giao.
\item[•] Ràng buộc \eqref{eqn:7} đảm bảo điểm bay và điểm đón drone phải được xe tải đến thăm.
\item[•] Ràng buộc \eqref{eqn:8} đảm bảo nếu drone bay từ điểm kho xe tải phải thăm điểm đón nó.
\item[•] Ràng buộc \eqref{eqn:9} đảm bảo rằng nếu \ac{DD} $\langle i,j,k \rangle $ thì xe tải luôn phải giao hàng ở $i$ trước ở $k$.
\item[•] Ràng buộc \eqref{eqn:10}, \eqref{eqn:11} đảm bảo không có 2 \ac{DD} nào có cùng điểm khách hàng\eqref{eqn:B}.
\item[•] Ràng buộc \eqref{eqn:12}, \eqref{eqn:13}, \eqref{eqn:14}, \eqref{eqn:15} đảm bảo nếu điểm $i$ được giao hàng trước điểm $j$ trong \ac{TD} thì thứ tự của chúng phải được đảm bảo.
\item[•] Ràng buộc \eqref{eqn:16} đảm bảo luôn luôn chỉ tồn tại một DD tại một thời điểm trên lộ trình \eqref{eqn:D}
\end{itemize}
\section{Thuật toán GRASP}
\label{section:grasp}
Trong phần này chúng tôi trình bày thuật toán A Greedy Randomized Adaptive Search Procedure (GRASP) cho bài toán min-cost TSPD. Thuật toán gồm hai bước: (1) thuật toán phân tách, (2) thuật toán tìm kiếm cục bộ. Ở bước 1, chúng tôi xây dựng thuật toán phân tách nhằm sinh lời giải cho bài toán min-cost TSPD từ lời giải của bài toán TSP, lời giải TSP được sinh ra bởi thư viện CBLSVR. Trong bước hai, thuật toán tìm kiếm cục bộ được sử dụng để cải thiện lời giải được sinh ra từ thuật toán phân tách trong bước trước. Trong bước này chúng tôi trình bày các toán tử được làm mới để phù hợp cho bàn toán min-cost TSPD. Thuật toán được trình bày cụ thể trong thuật toán \ref{alg:GRASP}.
\begin{algorithm}[H]
\caption{A Greedy Randomized Adaptive Search Procedure (GRASP)}
\textbf{Input:} Tập các điểm cần giao hàng, kho, các tham số về chi phí và khoảng cách, thời gian chờ đợi, mức chịu đựng của drone.
\textbf{Output:} Chi phí nhỏ nhất thư được và một hành trình cho xe tải và drone.
\begin{algorithmic}[1]
\State $bestSolution=null;$
\State $bestObjectValue=T;$
\State $iteration=0;$
\While{$iteration <n_{TSP}$} 
\State $iteration=iteration+1;$
\State $tour=\text{Sinh lời giải từ thư viện CBLSVR}$
\State $tspdSolution=\text{SplitAlgorithm(tour)};$
\State $tspdSolution=\text{LocalSearch(tspdSolution)};$
\If{$f(tspdSolution)<bestObjectValue$}
\State $bestSolution=tspdSolution;$
\State $bestObjectiveValue=f(tspdSolution);$
\State $iteration=0;$
\EndIf
\EndWhile\\
\Return $bestSolution$
\end{algorithmic}
\label{alg:GRASP}
\end{algorithm}
\subsection{Thuật toán phân tách}
Trong phần này chúng tôi sẽ trình bày thuật toán phân tách (bước 1 trong thuật toán GRASP). Thuật toán gồm 2 bước nhỏ: (1) xây dựng auxiliary graph, (2) sinh lời giải. \\

Ý tưởng của thuật toán phân tách là xây dựng lời giải min-cost TSPD từ TSP bằng cách tách các điểm giao hàng bằng drone. Bắt đầu từ một hành trình người du lịch (TSP) thuật toán chọn ra các điểm cần chuyển thành drone, với một điểm khách hàng được chọn giao bằng drone, điểm đó sẽ được xóa khỏi hành trình xe tải và hình thành một DD. Trong thuật toán này, để sinh lời giải \ac{TSP} chúng tôi sử dụng thư viện CBLSVR \cite{CBLSVR}.

\begin{algorithm}[H]
\caption{$\text{Thuật toán phân tách}$ \\ (Step 1: Xây dựng auxiliary graph và tìm đường đi ngắn nhất)}
\textbf{Data:} TSP tour s\\
\textbf{Result:} P lưu đường đi ngắn nhất từ auxiliary graph, V là giá trị của các đường đi ngắn nhất, và T là danh sách các DD có thể và giá trị của nó.
\begin{algorithmic}[1]
\State $arcs=\oslash;$
\State $T=\oslash;$

\ForEach{$i \quad \in \quad s,\textbackslash \text{last(s)}$}
\State $k=pos(i,s)+1;$
\State $arcs=arcs \cup \{(i,k,cost(i,k,s))\}; $
\EndFor
\ForEach{$i \  \in \ s \setminus \{last(s),s[pos(last(s),s)-1]\}$}
\ForEach {$k \ \in \ s:pos(k,s) \geq pos(i,s)+2$}

\State $minValue=\top;$
\State $minIndex=\top;$
\ForEach {$j \ \in \ s:pos(i,s) < pos(j,s)<pos(k,s)$}
\If {$\langle i,j,k \rangle \in P \ and |d_{i\rightarrow k}-(d'_{ij}+d'_{j,k})| < \bigtriangleup $}
\State $\begin{array}{l}cost = \\ cost(sub(i,k,s))+C_1(d_{prev(j,s)next(j,s)}-d_{prev(j,s),j}-d_{j,next(j,s)}+cost(i,j,k); \end{array}$
\If{cost<minValue}
\State $minValue=cost;$
\State $minIndex=pos(j,s);$
\EndIf
\EndIf
\EndFor
\State $arcs=arcs \cup \{(i,k,minValue)\};$
\If{$minIndex \neq \top$}
\State $T=T\cup\{(i,s[minIndex],k,minIndex)\};$
\EndIf
\EndFor
\EndFor
\State $V[0]=0.0;$
\State $P[0]=0;$
\ForEach{$k \ in \ s  \textbackslash \{0\}$}
\ForEach{$(i,k,cost) \in arcs$}
\If($V[k] > V[i]+cost$)
\State $V[k]>V[i]+cost;$
\State $P[k]=i;$
\EndIf
\EndFor
\EndFor\\
\Return $bestSolution$
\end{algorithmic}
\label{alg:SPLIT1}
\end{algorithm}
\subsubsection{Xây dựng auxiliary graph và tìm lộ trình ngắn nhất}
Trong thuật toán \ref{alg:SPLIT1} chúng tôi xây dựng một đồ thị $H=(V',A')$ dựa trên hành trình TSP $s$ của đồ thị $G=(V,A)$ với $V=V'$, mọi cạnh $arc(i,j) \in A'$ biểu diễn lộ trình con từ $i$ đến $j$ với điểu kiện $pos(i,s)<pos(j,s)$.

Với $i,j$ là hai đỉnh liên tiếp nhau chi phí $c_{i,j}$ của cạnh $arc(i,j)$ được tính bằng công thức:
$$c_{ij}=C_1d_{ij}$$ 

Tuy nhiên khi đỉnh $i,k$ không liên tiếp nhau mà đỉnh $j$ nằm giữa $i,k$ sao cho $\langle i,j,k \rangle \in P$
$$
c_{ik}=min_{\langle i,j,k \rangle \in P} cost(sub(i,k,s))+C_1(d_{prev_sj,next_sj}-d_{prev_sj,j}-d_{j,next_sj})+cost(i,j,k)
$$
Nếu đỉnh $i,k$ không liền nhau và không tồn tại đỉnh $j$ ở giữa $i,k$ sao cho $\langle i,j,k \rangle$ có thể là một DD thì:
$$c_{ik}=+\infty$$

Thuật toán tính chi phí cạnh trong đồ thị $H$ được trình bày từ dòng 1 đến dòng 25 trong thuật toán \ref{alg:SPLIT1}. Danh sách T chứa các DD được lưu lại để sử dụng cho thuật toán xây dựng lời giải (dòng 21 đến 22). \\

Đồ thị H được sử dụng để tính toán chi phí $v_k$ là đường đi ngắn nhất từ kho đến đỉnh $k$. Bởi vì đồ thị xây dựng là có hướng và không có chu trình nên giá trị $v_k$ có thể tính dễ dàng bằng thuật toán quy hoạch động. Hơn nữa, một cạnh trong đường đi ngắn nhất (một cung trong đồ thị H) $arc(i,k)$ hoàn toàn có thể tạo ra một DD với điểm bay là $i$, điểm đón là $k$. Chính lợi điểm này luôn luôn đảm bảo không có hai DD nào overlap tức một thời điểm không thể nào có hai drone đang bay.  \\

Cụ thể, đặt $v_0=0$ giá trị $v_k$ của mỗi đỉnh $k \in V'\textbackslash \{0\}$ được tính bằng: 
$$v_k=min\{v_i+c_{ik}:(i,k) \in A'\} \ \forall k=,2,\ldots,n+1$$
Chúng tôi lưu một mảng lưu vết P, $P(j), j=1,\ldots,n+1 $ là đỉnh trước đó của của $j$. Các bước xây dựng $v,P$ được trình bày trong thuật toán \ref{alg:SPLIT1} từ dòng 27 đến dòng 34. 

\begin{figure}

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (0) at (0,0){0};
\node[state] (6) at (2,0){6};
\node[state] (3) at (4,0){3};
\node[state] (5) at (6,0){5};
\node[state] (2) at (8,0){2};
\node[state] (1) at (10,0){1};
\node[state] (4) at (12,0){4};
\node[state] (7) at (14,0){7};
\path [->] (0) edge node[above] {225} (6);
\path [->] (0) edge[bend right=60] node[above] {413} (3);
\path [->] (0) edge[bend right=60] node[above] {$\infty$} (5);
\path [->] (0) edge[bend right=60] node[above] {$\infty$} (2);
\path [->] (0) edge[bend right=60] node[above] {1264} (1);
\path [->] (0) edge[bend right=60] node[above] {1258} (4);
\path [->] (0) edge[bend right=60] node[above] {1464} (7);
\path [->] (6) edge node[above] {175} (3);
\path [->] (6) edge[bend left=60] node[below] {390} (5);
\path [->] (6) edge[bend left=60] node[above] {$\infty$} (2);
\path [->] (6) edge[bend left=60] node[above] {938} (1);
\path [->] (6) edge[bend left=60] node[above] {989} (4);
\path [->] (6) edge[bend left=60] node[above] {1192} (7);
\path [->] (3) edge node[above] {300} (5);
\path [->] (3) edge[bend right=60] node[above] {569} (2);
\path [->] (3) edge[bend right=60] node[above] {$\infty$} (1);
\path [->] (3) edge[bend right=60] node[above] {859} (4);
\path [->] (3) edge[bend right=60] node[above] {1065} (7);
\path [->] (5) edge node[above] {250} (2);
\path [->] (5) edge[bend left=60] node[below] {368} (1);
\path [->] (5) edge[bend left=60] node[above] {419} (4);
\path [->] (5) edge[bend left=60] node[above] {767} (7);
\path [->] (2) edge node[above] {300} (1);
\path [->] (2) edge[bend right=60] node[above] {310} (4);
\path [->] (2) edge[bend right=60] node[above] {516} (7);
\path [->] (1) edge node[above] {50} (4);
\path [->] (1) edge[bend left=60] node[above] {257} (7);
\path [->] (4) edge node[above] {200} (7);

\end{tikzpicture}


\caption{Auxiliary graph cho lộ trình TSP được trình bày trong hình \ref{tsptspd} \cite{main}}\label{augraph}
\end{figure}
\subsubsection{Thuật toán sinh lời giải} 

Dựa vào P, T tìm được phần trước trong phần này chúng tôi trình bày thuật toán \ref{alg:SPLIT2} sinh lời giải cho bài toán min-cost TSPD.  Bước đầu tiên chúng tôi xây dựng một tập đỉnh $S_a=0,1,\ldots,n+1$ trình bày đường đi từ 0 đến n+1 trên auxiliary graph (dòng 1 đến dòng 8 trong thuật toán \ref{alg:SPLIT2}). Hai điểm gần nhau trong $S_a$ trình bày một lộ trình con trong lời giải. Tuy nhiên chúng ta vẫn phải xây dựng các DD tương ứng với mỗi lộ trình con đó. Các DD này đã được tính toán sẵn và lưu lại trong $T$ ở bước trước. \\

Lời giải cho bài toán min-cost TSPD gồm 2 thành phần TD và DDs ở đây chúng tôi định nghĩa $S_t$(TD) và $S_d$(DDs). Để xây dựng DDs, với một cập điểm $i,i+1$ trong $S_a$ xác định số điểm trong tourTSP nằm giữa hai điểm này, nếu có ít nhất một điểm nằm giữa hai điểm trên thì ta lấy DD với điểm đầu cuối tương ứng trong T bỏ vào DDs ($S_d$). Thuật toán được trình bày trong thuật toán \ref{alg:SPLIT2} dòng 10 đến 15.  \\

Để xây dựng TD, ta bắt đầu từ điểm 0 trong $S_a$. Mỗi cặp điểm $i,i+1$ trong  $S_a$ ta tạo ra một lộ trình con trong lời giải TSPD bằng việc lấy  các điểm khách hàng từ hành trình TSP. Tuy nhiên trong trường hợp $\langle i,j,i+1 \rangle$ là một DD thì ta phải loại bỏ $j$ ra khỏi TD.

\begin{algorithm}
\caption{$\text{Thuật toán phân tách }$ \\ (Step 2: Sinh lời giải từ step 1)}
\textbf{Input:} P lưu đường đi ngắn nhất từ auxiliary graph, V là giá trị của các đường đi ngắn nhất, và T là danh sách các DD có thể và giá trị của nó và tspTour là lộ trình của xe tải\\
\textbf{Output:} Chi phí và lời giải cho bài toán min-cost TSPD.
\begin{algorithmic}[1]
\State $i=\top;$
\State $S_a=\{j\}$
\While{$i\neq 0$}
\State $i=P[j]$
\State $S_a=S_a \cup \{i\}$
\State $j=i $  
\EndWhile
\State $S_a=S_a.reverse();$
\State $S_t=\oslash$ 
\For{$i=0;i<S_a.size-1;i++$}
\If{$\text{between } \ S_a[i] \ and \ S_a[i+1] \ in \ tspTour,\text{có ít nhất một điểm} $}
\State $n_{drone}=\text{drone node in T} $ 
\State $S_d=S_d \cup \langle S_a[i],n_drone,S_a[i+1]$
\EndIf
\EndFor 
\State $currentPosition=0$
\While {$currentPosition \neq n+1 $}
\If{$curentPosition \text{là một điểm bay của một DD t trong } S_d$}
\State $\begin{array}{l}  S_t=S_t+ \text{ tất cả các điểm thuộc } tspTour \\ \text{ nằm từ } currentPosition \text{ đến } t_{ rendezvous\_node }\text{ ngoại trừ } t_{ drone\_node } \end{array}$
\State $currentPosition=t_{rendezvous\_node}$
\Else
\State $S_t=S_t \cup currentPosition $
\State $curentPosition=tspTour[indexOf(currentPosition)+1]$
\EndIf
\EndWhile\\
\State $tspdSolution=(S_t,S_d)$\\
\Return $tspdSolution$
\end{algorithmic}
\label{alg:SPLIT2}
\end{algorithm}
\subsection{Các toán tử tìm kiếm cục bộ}
Trong phần này chúng tôi trình bày các toán tử  cho bài toán min-cost TSPD, bao gồm: (1) $relocate_T$, (2) $relocate_D$, (3) $remove_D$, (4) $two\_exchange$. \\

Hai toán tử tìm kiếm cục bộ được lấy cảm hứng từ truyền thống là $relocate\_truck$ và $two\_exchange$. Ngoài ra với dựa trên những đặc thù riêng biệt của bài toán min-cost TSPD chúng tôi trình bày thêm hai toán tử mới đó là "$drone\_relocate$" dùng để tạo ra một DD và "$drone\_removal$" dùng để xóa bỏ một DD. Để bắt đầu chúng ta định nghĩa một vài từ khóa sau:
\begin{itemize}
\item[-] $N_T(TD,DDs)=\{e:e \in TD,\langle e,.,. \rangle \notin DDs,\langle .,.,e \rangle \notin DDs\}$ là tập các điểm chỉ thuộc TD, không nằm trong bất kì DD nào.
\item[-] $N_D(TD,DDs)=\{e: \langle .,e,. \rangle \in DD\}$ là tập các điểm giao hàng drone trong lời giải TSPD.

Tiếp theo chúng tôi định nghĩa chi tiết từng toán tử nhu sau :
\begin{enumerate}
\item $relocation\_truck:$ Đây là toán tử truyền thống được làm mới để phù hợp với bài toán min-cost TSPD với hai điểm khác biệt sau: (1) chúng tôi chỉ cân nhắc các điểm thuộc $N_T$, (2) chúng tôi chỉ di chuyển nút vào các vị trí trong TD. Cụ thể ta định nghĩa
$$relocate_T((TD,DDs),a,b),a \in N_T((TD,DDs)),b \in TD, b \neq a, b \neq 0$$ 
là toán tử di chuyển điểm a đến trước điểm b trong TD.
\begin{figure}[H]

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (4);
\path [dashed] (2) edge[->] node[above] {} (3);
\path [dashed] (3) edge[->] node[above] {} (4);
\path [-] (4) edge[->] node[above] {} (5);
\path [-] (5) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (4);
\path [dashed] (2) edge[->] node[above] {} (3);
\path [dashed] (3) edge[->] node[above] {} (4);
\path [-] (4) edge[->] node[above] {} (5);
\path [-] (5) edge[->, bend left=40] node[above] {} (8);
\path [-] (8) edge[->, bend right=30] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->, bend right=30] node[above] {} (9);

\end{tikzpicture}
\caption{Toán tử $truck\_relocation$}\label{opeatorRT}
\end{figure}
\item $Drone\_relocation$: ý tưởng của toán tử là chuyển một điểm giao hàng bằng xe tải sang drone hoặc di chuyển điểm giao hàng drone qua các điểm bay và điểm đón mới. Cụ thể chúng tôi định nghĩa :
$$\begin{array}{c} relocate_D((TD,DDs),a,i,k)\\ a \in N_T(TD,DD) \cup N_D(TD,DDs),i,k, \in TD \textbackslash \{a\},\\ i \neq k, pos(i,TD) < pos(k,TD), \langle i,a,k \rangle \in P \end{array}$$ là một toán tử thực hiện xây dựng DD $\langle i,a,k \rangle$. Có hai trường hợp xảy ra: (1) nếu $a$ là một điểm giao hàng bởi xe tải, toán tử sẽ thực hiện tạo $\langle i,a,k \rangle$ sau đó xóa bỏ $a$ khỏi TD, (2) nếu $a$ là \ac{DD} toán tử thực hiện thay đổi điểm bay và điểm đón của DD đó thành  $\langle i,a,k \rangle$.
\begin{figure}[H]

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (4);
\path [dashed] (2) edge[->] node[above] {} (3);
\path [dashed] (3) edge[->] node[above] {} (4);
\path [-] (4) edge[->] node[above] {} (5);
\path [-] (5) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (4);
\path [dashed] (2) edge[->] node[above] {} (3);
\path [dashed] (3) edge[->] node[above] {} (4);
\path [-][dashed] (4) edge[->] node[above] {} (5);
\path [-][dashed] (5) edge[->] node[above] {} (6);
\path [-] (4) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}
\caption{Toán tử $drone\_relocation$}\label{opeatorRD}
\end{figure}
\item $Drone\_Removal:$ Trong toán tử này chúng ta chọn một điểm giao hàng bằng drone bất kì và di chuyển nó thành điểm giao hàng bởi xe tải. Chi tiết, chúng tôi định nghĩa toán tử :
$$remove_D((TD,DD),j,k),j \notin TD, \langle .,j,. \rangle \in DDs,k \in TD,k \neq\{0,n+1\}$$ 
xóa bỏ DD $\langle .,j,. \rangle$ và điểm giao hàng bằng drone $j$ được  chuyển thành điểm giao hàng bằng xe tải và đặt trước $k$ trong TD.
\begin{figure}[H]

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (4);
\path [dashed] (2) edge[->] node[above] {} (3);
\path [dashed] (3) edge[->] node[above] {} (4);
\path [-] (4) edge[->] node[above] {} (5);
\path [-] (5) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (3);
\path [-] (3) edge[->] node[above] {} (4);
\path [-] (4) edge[->] node[above] {} (5);
\path [-] (5) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}
\caption{Toán tử $drone\_removal$}\label{opeatorDR}
\end{figure}
\item $two\_exchange$ : Ở toán tử này, chúng tôi đổi vị trí hai điểm bất kì trong lời giải, có 3 khả năng có thể xảy ra: (1) đổi vị trí của hai điểm giao hàng bởi drone, (2) đổi vị trí giao hàng của 2 điểm giao hàng bằng xe tải,(3) đổi điểm giao hàng giữa hai phương tiện. Chi tiết,  ta định nghĩa toán tử :
$$two\_exchange((TD,DDs),a,b),a,b),a,b \in V \textbackslash \{0,n+1\}, a \neq b$$ ta đổi vị trí hai điểm $a,b$ tương ứng với 3 trường hợp.
\begin{figure}[H]

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);

\path [-] (2) edge[->] node[above] {} (3);
\path [-] (3) edge[->] node[above] {} (4);
\path [dashed] (4) edge[->] node[above] {} (5);
\path [dashed] (5) edge[->] node[above] {} (6);
\path [-] (4) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->,bend left=45] node[above] {} (5);
\path [-] (5) edge[->] node[above] {} (4);
\path [dashed] (4) edge[->] node[above] {} (3);
\path [dashed] (3) edge[->] node[above] {} (6);
\path [-] (4) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}
\caption{Toán tử $two\_exchange$}\label{opeatorTE}
\end{figure}
\end{enumerate}
\end{itemize}
Tất nhiên khi sử dụng tất cả các toán tử trên phải thỏa mãn các ràng buộc của bài toán min-cost TSPD.
\section{Thuật toán tìm kiếm cục bộ}
\label{section:tsp-ls}
Trong phần này chúng tôi sẽ trình bày một thuật toán tìm kiếm cục bộ để giải quyết bài toán TSPD. Ý tưởng chủ đạo của thuật toán như sau: thuật toán bắt đầu bằng một hành trình người du lịch sau đó liên tục thay đổi vị trí khách hàng trong lộ trình đến bao giờ không có phép đổi nào có thể làm giảm được chi phí nữa, cụ thể được trình bày bởi thuật toán \ref{alg:tspls}. Dòng 1-8 khởi tạo các biến toàn cục, cụ thể:
\begin{itemize}
\item[-] $Customers$ : $n$ khách hàng đánh số từ $1\rightarrow n$.
\item[-] $truckRoute$ : \ac{TD}
\item[-] $truckSubRoute$ chứa  tất cả các tập con của $truckRoute$ tức là chứa tất cả các $subroute$ có thể của $truckRoute$ ($subroute$ là một chuỗi lộ trình con của $truckRoute$).
\item[-] $i^* \ j^* \ k^*$ với $j^*$ là khách hàng cần đổi chỗ nhất và giữa khách hàng $i^* ,k^*$ là vị trí tốt nhất để đặt khách hàng $j^*$ trong lộ trình.
\item[-] $maxSavings$ : giá trị giảm được sau khi đặt lại vị trí của $j^*$.
\item[-] $isDroneNode$: xác định có phải là một thao tác tạo \ac{DD}
\item[-] $Stop$: xác định kết thúc vòng lặp thuật toán hay tiếp tục.
\end{itemize}
Thuật toán sẽ dừng lại khi $maxSavings$ không còn dương. \\

Trong thuật toán  \ref{alg:tspls} ta định nghĩa 
$$
drone(s,(TD,DDs))= \Vast\{
\begin{array}{ll}
		True & \begin{array}{l}
		\text{if}	\	\exists \ j \in V(s),\ j \neq first(s), \\ j \neq last(s): \langle first(s),j,last(s) \rangle \in DDs
		\end{array}  \\
		False &  \begin{array}{l}
		\text{if}	\	\forall \ j \in V(s),\ j \neq first(s), \\ j \neq last(s): \langle first(s),j,last(s) \rangle \notin DDs
		\end{array}
\end{array}
$$
\begin{algorithm}[H]
\caption{TSP-LS heuristic}
\textbf{Input:} Tập các điểm cần giao hàng, kho. Các tham số về chi phí và khoảng cách, thời gian chờ đợi, mức chịu đựng của drone.\\
\textbf{Output:} Chi phí nhỏ nhất thư được và một hành trình cho xe tải và drone.
\begin{algorithmic}[1]
\State $Customers = N ;$
\State $truckRoute = solveTSP(N);$
\State $truckSubRoutes = {truckRoute};$
\State $sol = \{truckRoute,  \oslash \};$
\State $i^*=-1;$
\State $j^*=-1;$
\State $k^*=-1;$
\State $maxSavings = 0;$
\State $isDroneNode = null;$
\State $Stop = f alse;$
\Repeat
\ForEach{$j \in Customers$}
\State savings=calcSaving(j)
\ForEach{subroute in truckSubRoute}
\If{drone(subroute,sol)}
\State $\begin{array}{l}
	isDroneNode,maxSavings,i^*,j^*,k^*)=\\
	relocateAsTruck(j,subroute,savings);
\end{array}$ 
\Else
\State $\begin{array}{l}
isDroneNode,maxSavings,i^*,j^*,k^*)= \\ relocateAsDrone(j,subroute,savings);
\end{array}$
\EndIf
\EndFor
\If{maxSavings>0} 
\State{$\begin{array}{l}
(sol,truckRoute,truckSubRoute,Customers)
= applyChange(isDroneNode, \\ i^*,j^*,k^*,sol,trucRoute,trucSubRoute,Customers)
\end{array};$}
\State $maxSavings=0;$
\Else 
\State $Stop=true;$
\EndIf
\EndFor
\Until{Stop}
\end{algorithmic}
\label{alg:tspls}
\end{algorithm}
%\begin{figure}[H]
%\includegraphics[scale=0.8]{alo4.png}
%\end{figure}
Trong mỗi vòng lặp thực hiện hai hai bước: (1) Cân nhắc xem có khách hàng nào khi di chuyển đến vị trí mới trong lộ trình tạo ra kết quả tốt nhất; (2) Cân nhắc xem việc di chuyển khách hàng đó có làm lời giải hiện tại tốt lên không. Nếu có thì cập nhật lời giải hiện tại, $truckRoute \ \text{và} \ subTruckRoute$ và xóa khách hàng đó trong danh sách khách hàng, ngược lại việc di chuyển khách hàng không làm lời giải tốt lên thuật toán sẽ kết thúc. Cả hai bước trên được trình bày trong thuật toán \ref{alg:tspls}, \ref{alg:tspls2}, \ref{alg:tspls3}, \ref{alg:tspls4}, \ref{alg:tspls5}.
Bước 1 được thể hiện từ dòng 13 đến 20 trong thuật toán \ref{alg:tspls}. Thuật toán cân nhắc mỗi khách hàng $j$ và tính chi phí nếu xóa bỏ $j$ khỏi vị trí hiện tại. Việc tính toán sẽ được trình bày trong thuật toán \ref{alg:tspls2}. Sau đó thuật toán sẽ thử đặt khách hàng $j$ vào các $subroute$. Khi $subroute$ đang xét có hai điểm đầu cuối lần lượt là điểm bay và điểm đón drone thì ta thử đặt $j$ vào lộ trình xe tải trong $subroute$. Ngược lại ta sẽ thử đặt $j$ vào một \ac{DD} mới. Thuật toán tính toán chi phí khi đặt $j$ vào \ac{TD} và \ac{DD} được trình bày bởi thuật toán \ref{alg:tspls3}, \ref{alg:tspls4}.   \\

\begin{algorithm}[H]
\caption{calcSavings(j)}
\textbf{Input:} j : khách hàng trong TD\\
\textbf{Output:} Giá trị chi phí giảm đi.
\begin{algorithmic}[1]
\State $i=prev_{truckRoute}(j);$
\State $k=next_{truckRoute}(j);$
\State $savings=(d_{i,j}+d_{j,k}-d_{i,k};$\\
\Return $savings;$
\end{algorithmic}

\label{alg:tspls2}
\end{algorithm}

Trong thuật toán \ref{alg:tspls3} mục tiêu của chúng tôi là tìm ra vị trí tốt nhất trong $subroute$ $s$ để đặt khách hàng $j$. Việc này được thực hiện bởi việc đặt thử khách hàng $j$ vào giữa các điểm liên tiếp nhau trong $s$. Đầu tiên chúng ta sẽ phải kiểm tra xem việc đặt $j$ vào giữa cặp khách hàng $i$, $k$ không vi phạm bất kì ràng buộc về thời gian chờ đợi nào trong các $subroute$ khác. Sau đó ta kiểm tra việc đặt $j$ vào phải mất chi phí nhỏ hơn $savings$. Vì tồn tại một nút \ac{DD} nằm trên $s$ nên ta phải kiểm tra xem việc đặt thêm $j$ vào có làm vượt quá giới hạn năng lượng của drone không. Cuối cùng kiểm tra xem việc đặt $j$ ở giữa $i$,$k$  có phải là lời giải tốt nhất hiện tại không cập nhật giá trị mới cho $i^*,j^*,k^*, maxSavings$.

\begin{algorithm}[H]
\caption{relocateAsTruck($j,s,savings$)\\(Tính toán trị phí của việc chuyển khách hàng $j$ đến vị trí mới trong lộ trình)}
\textbf{Input:} $j$ : khách hàng trong TD\\ $s$: $subroute$ cân nhắc đặt khách hàng $j$ \\ $savings$: lượng thay đổi nếu xóa bỏ $j$ khỏi vị trí của nó\\
\textbf{Output:} Kết quả cập nhật vào các biến $i^*, \ j^*, \ k^*$ và $isDroneNode$
\begin{algorithmic}[1]
\State $a=first(s);$
\State $b=last(s);$
\ForEach{$(i,k) \in A(s)$}
\If{việc đặt $j$ vào vị trí này không vi phạm bất kì ràng buộc về thời gian chờ đợi nào của các $subroute$ khác}
\State{$\delta=(d_{i,j}+d_{j,k}-d_{i,k})C_1$}
\If{$\delta<savings$}
\If{$dist_T(s)+(d_{i,j}+d_{j,k}-d_{i,k})< \epsilon$}
\If{$savings-\delta>maxSavings$}
\State $isDroneNode=False;$
\State $j^*=j;i^*=i;k^*=k;$
\State $maxSaving=saving-\delta;$
\EndIf
\EndIf
\EndIf
\EndIf
\EndFor\\
\Return 	$(isDroneNode,maxSavings,i^*,j^*,k^*)$
\end{algorithmic}

\label{alg:tspls3}
\end{algorithm}
\begin{figure}[H]
\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state1] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [->] (1) edge node[above] {} (2);
\path [->] (2) edge node[above] {} (3);
\path [->] (3) edge node[above] {} (5);
\path [->,dashed] (3) edge node[above] {} (4);
\path [->,dashed] (4) edge node[above] {} (5);
\path [->] (5) edge node[above] {} (6);
\path [->] (6) edge node[above] {} (7);
\path [->] (7) edge node[above] {} (8);
\path [->] (8) edge node[above] {} (9);

\end{tikzpicture}
\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state1] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [->] (1) edge node[above] {} (2);
\path [->] (2) edge node[above] {} (3);
\path [->] (3) edge[bend right=45] node[above] {} (7);
\path [->,dashed] (3) edge node[above] {} (4);
\path [->,dashed] (4) edge node[above] {} (5);
\path [->] (7) edge[bend left=45] node[above] {} (5);
\path [->] (5) edge node[above] {} (6);
\path [->] (6) edge[bend left=45] node[above] {} (8);
\path [->] (8) edge node[above] {} (9);

\end{tikzpicture}
\caption{Mô phỏng thao tác relocateAsTruck}\label{reloAsTruck}
\end{figure}
Trong thuật toán \ref{alg:tspls4} chúng tôi tính toán chi phí nếu chuyển $j$ thành khách hàng giao bởi một \ac{DD}. Điều này được thực hiện bởi biến $\langle i,j,k \rangle$ thành một \ac{DD}, với $i$,$k$ là 2 điểm trong $s$. Tương tự với thuật toán \ref{alg:tspls3} ta phải kiểm tra xem \ac{DD} vừa tạo có thỏa mãn không. Nếu việc chuyển $j$ vào một \ac{DD} là lời giải tốt nhất hiện tại thì cập nhật  giá trị mới cho $i^*,j^*,k^*, maxSavings$.\\

\begin{algorithm}[H]
\caption{relocateAsDrone($j,s,savings$)\\(Tính toán chi phí của việc chuyển khách hàng $j$ sang giao hàng bằng drone)}
\textbf{Input:} $j$ : khách hàng trong \ac{TD}\\ $s$: $subroute$ cân nhắc đặt khách hàng $j$ \\ $savings$: lượng thay đổi nếu xóa bỏ $j$ khỏi vị trí của nó\\

\textbf{Output:} Kết quả cập nhật vào các biến $i^*, \ j^*, \ k^*$ và $isDroneNode$
\begin{algorithmic}[1]
\For{$i=0$, $size(s) -2 $}
\For{$k=i+1$, $size(s)-1 $}
\If{$\langle s[i],j,s[k] \rangle \in P$}
\State$\delta =(d_{s[i],j}'+d_{j,s[k]}')C_2;$
\If{$savings-\delta>maxSavings$}
\State $isDroneNode=True;$
\State  $j^*=j;i^*=s[i];k^*=s[k];$
\State $maxSavings=saving-\delta;$
\EndIf
\EndIf
\EndFor
\EndFor\\
\Return 	$(isDroneNode,maxSavings,i^*,j^*,k^*)$
\end{algorithmic}

\label{alg:tspls4}
\end{algorithm}
\begin{figure}[H]
\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state1] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [->] (1) edge node[above] {} (2);
\path [->] (2) edge node[above] {} (3);
%\path [-] (3) edge node[above] {} (5);
\path [->] (3) edge node[above] {} (4);
\path [->] (4) edge node[above] {} (5);
\path [->] (5) edge node[above] {} (6);
\path [->] (6) edge node[above] {} (7);
\path [->] (7) edge node[above] {} (8);
\path [->] (8) edge node[above] {} (9);

\end{tikzpicture}
\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state1] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [->] (1) edge node[above] {} (2);
\path [->] (2) edge node[above] {} (3);
\path [->] (3) edge node[above] {} (5);
\path [->, dashed] (3) edge node[above] {} (4);
\path [->, dashed] (4) edge node[above] {} (5);
\path [->] (5) edge node[above] {} (6);
\path [->] (6) edge node[above] {} (7);
\path [->] (7) edge node[above] {} (8);
\path [->] (8) edge node[above] {} (9);

\end{tikzpicture}
\caption{Mô phỏng thao tác relocateAsDrone}\label{reloAsDrone}
\end{figure}
Trong thuật toán \ref{alg:tspls5} thực hiện công việc cập nhật lời giải nếu $maxSavings \neq 0$ vì vậy nếu $isDroneNode=true $ tức là thực hiện tạo một \ac{DD} mới, ngược lại thực hiện thay đổi \ac{TD}. Nếu là tạo một \ac{DD} mới thì thuật toán thực hiện tạo \ac{DD} $\langle i^*,j^*,k^* \rangle$ và sau đó cập nhật $truckRoute,subTruckRoute$ sau đó xóa bỏ $i^*,j^*,k^*$ khỏi tập $Customers$. Nếu là cập nhật \ac{TD} thì ta chỉ cần thực hiện xóa bỏ $j^*$ khỏi vị trí cũ và cập nhật $j^*$ vào vị trí mới giữa $i^*$ và $k^*$. \\

Quay lại thuật toán \ref{alg:tspls} thuật toán sẽ kiểm tra xem nếu $maxSaving \neq 0$ thì sẽ thực hiện $applyChanges$ còn không thì vòng lặp sẽ dừng lại.
\begin{algorithm}[H]
\caption{applyChanges}
\textbf{Input:} $isDroneNode,i^* \ j^* \ k^*,sol,truckRoute,truckSubRoute,Customers$\\
\textbf{Output:} Cập nhật $truckRoute,truckSubRoute,sol$\\
\begin{algorithmic}[1]
\If{$isDroneNode == True$}
\State{Thêm mới một DD $i^* \rightarrow j^* \rightarrow k^*$}
\State{Xóa bỏ $j^*$ trong $truckRoute$ và $subTruckRoute$}
\State{Cập nhật $truckSubRoute$}
\State{Xóa bỏ $i^* \ j^* \ k^*$ trong $Customers$}
\Else 
\State{Xóa bỏ $j^*$ ở truck $subroute$ hiện tại}
\State{Cập  nhật $j^*$ vào vị trí mới giữa $i^*$ và $k^*$}
\EndIf
\State {Cập nhật $sol$} \\
\Return 	$(sol,truckRoute,Customers)$
\end{algorithmic}

\label{alg:tspls5}
\end{algorithm}
\chapter{Đề xuất thuật toán tìm kiếm cục bộ  giải bài toán  lập lộ trình vận tải giao hàng kết hợp một xe tải và nhiều thiết bị bay}
\label{chapter:tspkd}
Trong chương này chúng tôi đề xuất bài toán lập lộ trình vận tải giao hàng kết hợp một xe tải và nhiều thiết bị bay và một thuật toán tìm kiếm cục bộ giải quyết bài toán. Cụ thể, phần \ref{section:intspkd} sẽ giới thiệu và trình bày lý do xuất phát của bài toán lập lộ trình giao hàng kết hợp một xe tải và  nhiều thiết bị bay không người lái, phần \ref{section:pbtspkd} sẽ trình bày phát biểu bài toán, biến và các mô hình, phần \ref{section:tspkdalo} chúng tôi sẽ trình bày một thuật toán tìm kiếm cục bộ giải quyết bài toán này.
\section{Bài toán lập lộ trình giao hàng kết hợp xe tải và nhiều thiết bị bay}
\label{section:intspkd}
Trong phần trước chúng ta đã có cái nhìn tổng quan về bài toán lập lộ trình giao hàng kết hợp giữa xe tải và drone. Trong phần  này chúng tôi trình bày một nâng cấp của bài toán min-cost TSP-D. Trong phần \ref{section:tspd}, chúng tôi cũng đã nêu lên các ưu điểm của drone so với xe tải và hiệu quả của phương pháp giao hàng kết hợp giữa xe tải và drone. Chính vì điều ấy, chúng tôi nhận thấy rằng nếu sử dụng nhiều hơn một thiết bị bay drone trong một lộ trình vận tải giao hàng cùng với xe tải có thể sẽ đem lại hiệu quả hơn nữa. Hơn nữa, trong thực tế một xe tải với khả năng của nó hoàn toàn có thể mang nhiều hơn một drone. Dựa trên những nhận xét ban đầu như vậy chúng tôi xây dựng một nâng cấp của bài toán min-cost TSPD là bài toán min-cost TSPkD.
\section{Phát biểu bài toán}
\label{section:pbtspkd}
Một công ty phân phối hàng hóa có xe tải và đội drone. Trong đó một cặp xe tải và $k$ drone ($k \in N$) thực hiện một lộ trình giao hàng cho $n$ khách hàng sao cho thỏa mãn các yêu cầu sau.
\begin{itemize}
\item[-] Xe tải và các drone xuất phát từ điểm kho và quay lại kho khi hoàn thành lộ trình giao hàng.
\item[-] Drone luôn phải xuất phát và giao hàng từ xe tải, sau đó quay lại xe tải sau mỗi chuyến giao hàng.
\item[-] Điểm xuất phát và điểm kết thúc một chuyến giao hàng đều phải là một điểm khách hàng.
\item[-] Mỗi một chuyến giao hàng drone chỉ giao một khách hàng.
\item[-] Mối khách hàng chỉ được giao bời drone hoặc xe tải và chỉ duy nhất một drone hoặc xe tải.
\item[-] Chuyến giao hàng của drone không được vượt quá mức năng lượng cho phép $\varepsilon$ 
\item[-] Hai phương tiện phải chờ nhau nếu không đến cùng lúc tại điểm đón. Thời gian chờ nhau không được vượt quá $\Delta$.
\item[-] Với một điểm khách hàng là điểm đón và điểm bay của nhiều chuyến drone. Xe tải luôn phải đợi tất cả drone về rồi mới thực hiện thả drone đi thực hiện các chuyến tiếp. Nếu điểm đó là điểm bay của nhiều drone các drone coi như được thả đi cùng một thời điểm.
\item[-] Tại một thời điểm bất kì không được có vượt quá $k$ thiết bị bay cùng đang hoạt động.
\item[-] Chi phí trên một đơn vị độ dài của drone $C_2$ là của xe tải là $C_1$ . Drone chỉ mất phí khi đang trong một chuyến giao hàng. Tổng chi phí của chuyền giao hàng bằng tổng chi phí của xe tải và drone cộng lại.
\item[-] Hàm mục tiêu cho bài toán là tối thiểu tổng chi phí của lộ trình giao hàng.
\end{itemize}
\section{Thuật toán tìm kiếm cục bộ giải quyết bài toán lập lộ trình giao hàng kết hợp một xe tải và nhiều thiết bị bay} 
\label{section:tspkdalo}
Nhận thấy bài toán min-cost \ac{TSPkD} sẽ dần tới bài toán \ac{TSP} khi $\varepsilon$ tiến dần đến 0, vì vậy bài toán là NP-hard. Chính vì vậy chúng tôi lựa chọn hướng tiếp cận thuật giải gần đúng cụ thể là thuật toán tìm kiếm cục bộ để giải quyết bài toán. Trong phần \ref{subsection:ttmove} chúng tôi sẽ trình bày toán tử move mà chúng tôi sử dụng trong thuật toán, phần \ref{subsection:tspkdal} là trình bày chi tiết thuật toán.
\subsection{Toán tử move}
\label{subsection:ttmove}
Trong phần trước chúng tôi đã trình bày toán tử move $relocate_D$ trong đó thực hiện lấy một phần tử từ \ac{TD} thiết lập một \ac{DD}. Nếu ta đem y nguyên toán tử này sang áp dụng cho bài toán min-cost \ac{TSPkD} thì gặp một vài bất cập. Cụ thể xem xét ví dụ trong hình \ref{exTSPkD}.
\begin{figure}[H]
\begin{subfigure}{1\textwidth}
\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,0){3};
\node[state] (4) at (6,2){4};
\node[state] (5) at (8,2){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (3);
\path [-] (3) edge[->] node[above] {} (4);
\path [-] (4) edge[->] node[above] {} (5);
\path [-] (5) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}
\caption{Lộ trình \ac{TSP} ban đầu}
\label{exTSPkD1}
\end{subfigure}
\begin{subfigure}{1\textwidth}
\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,0){3};
\node[state1] (4) at (6,2){4};
\node[state] (5) at (8,2){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (3);
\path [dashed] (3) edge[->] node[above] {} (4);
\path [dashed] (4) edge[->] node[above] {} (5);
\path [-] (3) edge[->] node[above] {} (5);
\path [-] (5) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}
\caption{Lời giải ứng với toán tử $relocation_D$}
\label{exTSPkD2}
\end{subfigure}
\begin{subfigure}{1\textwidth}
\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,0){3};
\node[state1] (4) at (6,2){4};
\node[state1] (5) at (8,2){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (3);
\path [-] (3) edge[->] node[above] {} (6);
\path [dashed] (3) edge[->] node[above] {} (4);
\path [dashed] (4) edge[->] node[above] {} (6);
\path [dashed] (3) edge[->] node[above] {} (5);
\path [dashed] (5) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}
\label{exTSPkD3}
\caption{Lời giải đúng cho bài toán min cost \ac{TSPkD}}
\end{subfigure}
\caption{Vi dụ cho thao tác $relocate_D$ sang bài toán min-cost \ac{TSPkD}}\label{exTSPkD}
\end{figure}

Với toán tử $relocate_D$ từ hành trình \ac{TSP} ban đầu (hình \ref{exTSPkD1}), ta lựa chon điểm 4 là điểm khách hàng bằng xe tải cần chuyển sang giao hàng bằng drone. Trong bước chọn vị trí của điểm bay và điểm đón cho 4 thuật toán sẽ lựa chọn sao cho chi phí giảm được là lớn nhất, vì vậy 3 và 5 được chọn. Nhận thấy ngay, việc lựa chọn này sẽ khiến 5 trở thành một điếm đón drone và không thể chuyển thành điểm drone nữa. Để tránh trường hợp này chúng tôi đề xuất một toán tử mới trong đó cả điểm 4 và 5 đều được lấy ra khỏi lộ trình của xe tải. \\

Toán tử move-$t$-point thực hiện chuyển $t$ điểm liên tiếp trong lộ trình thành $t$ DD, các bước thực hiện như sau: 
\begin{itemize}
\item[-] Bước 1: Chọn $t$ điểm giao hàng liên tiếp trong lộ trình $\langle v_1,v_2,\ldots,v_t \rangle$
\item[-] Bước 2: Xóa bỏ $t$ điểm giao hàng vừa chọn ra khỏi lộ trình.
\item[-] Bước 3: Với mỗi $v_i$ ta thực hiện các bước: 
\begin{enumerate}
\item Tìm hai điểm $v_{il}$ $v_{ir}$ trong lộ trình sao cho lượng chi phí .
\item Tạo \ac{DD} mới với $v_{il}$ $v_{i}$ $v_{ir}$
\end{enumerate}
\end{itemize}

\begin{figure}[H]

\begin{tikzpicture}[
state/.style ={circle,draw},state1/.style ={circle,dashed,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state1] (3) at (4,-1){3};
\node[state1] (4) at (6,1){4};
\node[state1] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (3);
\path [-] (3) edge[->] node[above] {} (4);
\path [-] (4) edge[->] node[above] {} (5);
\path [-] (5) edge[->] node[above] {} (6);
\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}
\caption{Chọn 3 điểm liên tiếp -- thao tác move-3-point}\label{mov3point1}
\end{figure}
\begin{figure}[H]

\begin{tikzpicture}[
state/.style ={circle,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (6);

\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}
\caption{Xóa bỏ t điểm vừa chọn ra khỏi lộ trình -- thao tác move-3-point}\label{mov3point2}
\end{figure}
\begin{figure}[H]

\begin{tikzpicture}[
state/.style ={circle,draw}]
\node[state] (1) at (0,0){1};
\node[state] (2) at (2,0){2};
\node[state] (3) at (4,-1){3};
\node[state] (4) at (6,1){4};
\node[state] (5) at (8,1){5};
\node[state] (6) at (10,0){6};
\node[state] (7) at (12,0){7};
\node[state] (8) at (14,0){8};
\node[state] (9) at (16,0){9};

\path [-] (1) edge[->] node[above] {} (2);
\path [-] (2) edge[->] node[above] {} (6);
\path [dashed] (2) edge[->] node[above] {} (3);
\path [dashed] (3) edge[->] node[above] {} (6);
\path [dashed] (2) edge[->] node[above] {} (4);
\path [dashed] (4) edge[->] node[above] {} (6);
\path [dashed] (7) edge[->, bend right=10] node[above] {} (5);
\path [dashed]  (5) edge[->, bend left=30] node[above] {} (8);

\path [-] (6) edge[->] node[above] {} (7);
\path [-] (7) edge[->] node[above] {} (8);
\path [-] (8) edge[->] node[above] {} (9);

\end{tikzpicture}
\caption{Chuyển các nút chọn thành DD -- thao tác move-3-point}\label{mov3point3}
\end{figure}

Mô phỏng một thao tác $move-3-point$ được thể hiện qua các hình \ref{mov3point1}, \ref{mov3point2}, \ref{mov3point3}. Bước 1 ta chọn 3 điểm liên tiếp nhau vd:  điểm 3, 4, 5 (Hình \ref{mov3point1}). Bước 2 ta xóa bỏ 3 điểm vừa chọn ra khỏi lộ trình (Hình \ref{mov3point2}). Bước 3 với điểm giao hàng 3:\begin{enumerate}
\item Thực hiện chon điểm bay và điểm đón cho DD có điểm giao hàng 3 là điểm 2 và điểm 6.
\item Thực hiện xây dựng DD tạo bởi 2,3 6.
\end{enumerate} 
Lặp lại bước 3 với điểm 4,5.
\subsection{Thuật toán tìm kiếm cục bộ}
\label{subsection:tspkdal}
Trong phần này chúng tôi trình bày thuật toán tìm kiếm cục bộ sử dụng các thao tác move trình bày trong các phần trước. Ý tưởng của thuật toán như sau: Băt đầu từ từ một hành trình của bài toán người du lịch, thuật toán sử dụng thao tác move sao cho không còn thao tác move nào có thể làm giảm chi phí nữa, cụ thể được trình bày trong thuật toán \ref{alg:tspkdls}.

\begin{algorithm}[H]
\caption{TSPkD-LS heuristic}
\textbf{Input:} Tập các điểm cần giao hàng, kho, các tham số về chi phí và khoảng cách, thời gian chờ đợi, mức chịu đựng của drone.\\
\textbf{Output:} Chi phí nhỏ nhất thư được và một hành trình cho xe tải và drone.
\begin{algorithmic}[1]
\State $truckRoute = solveTSP(N);$
\State $tour = (truckRoute, droneDeliveryList);$
\State $maxSavings = 0;$
\State $Stop = false;$
\Repeat
\If{$maxSaving<relocate_T(tour)$}
\State $\begin{array}{l}
maxSaving=relocate_T(tour); \\
\text{Lưu vị trí } relocate_T
\end{array}$
\ElsIf{$maxSaving<relocate_D(droneDeliveryList)$} 
\State $\begin{array}{l}
maxSaving=relocate_D(droneDeliveryList); \\
\text{Lưu vị trí } relocate_D
\end{array}$
\ElsIf{$maxSaving<remove_D(tour)$}
\State $\begin{array}{l}
maxSaving=remove_D(tour) \\
\text{Lưu vị trí } remove_D
\end{array}$
\ElsIf{$maxSaving<relocate_T(tour)$}
\State $\begin{array}{l}
maxSaving=relocate_T(tour); \\
\text{Lưu vị trí } relocate_T
\end{array}$
\ElsIf{$maxSaving<two\_exchange(tour)$}
\State $\begin{array}{l}
maxSaving=two\_exchange(tour); \\
\text{Lưu vị trí } two\_exchange
\end{array}$
\ElsIf{$maxSaving<kpointmove(tour)$}
\State $\begin{array}{l}
maxSaving=move\_t\_point(tour); \\
\text{Lưu vị trí } move\_t\_point
\end{array}$
\EndIf
\If{maxSavings>0} 
\State{$\begin{array}{l}
\text{Cập nhật lại trạng thái của tour theo toán tử move cho kết quả tốt nhất}
\end{array}$}
\State $maxSavings=0;$
\Else 
\State $Stop=true;$
\EndIf

\Until{Stop}
\end{algorithmic}
\label{alg:tspkdls}
\end{algorithm}
Trong thuật toán \ref{alg:tspkdls} chúng tôi thực hiện tính toán chi phí giảm đi với tất cả các toán tử sau đó lựa chọn toán tử cho chi phí giảm nhiều nhất và chuyển bài toán sang trạng thái mới. Dòng 6 -18 là lựa chọn toán tử cho chi phí giảm nhiều nhất. Các toán tử $relocate_D, relocate_T, remove_D, two\_exchange$ được trình bày từ các phần trước chúng tôi xin phép không trình bày lại trong phần này. Mã giả toán tử move-$t$-point được trình bày trong thuật toán \ref{alg:kpointmove}.
\begin{algorithm}[H]

\caption{caculateSavingPoints($i,t$)}
\textbf{Input:} $i$ vị trí điểm đầu tiên được lấy tra trong $truckRoute$, $t$ số điểm được lấy ra trong $truckRoute$\\
\textbf{Output:} Chi phí giảm đi sau khi lấy $t$ điểm bắt đầu từ $i$ ra khỏi $truckRoute$

\begin{algorithmic}[1]
\State $savings=0;$
\For{$j=i, i+t-1$}
\State $p=prev_{truckRoute}(j);$
\State $q=next_{truckRoute}(j);$
\State $savings=savings+ d_{p,q}C_;1$
\EndFor
\State $p=prev_{truckRoute}(i);$
\State $q=next_{truckRoute}(i+t-1);$
\State $savings=savings- d_{p,q}C_1;$

\Return $savings$.
\end{algorithmic}
\label{alg:caculateSavingPoints}
\end{algorithm}
Ý tưởng của thủ tục $move\_t\_point$ \ref{alg:kpointmove} như sau. Chúng tôi xem xét tất cả các $move\_t\_point$ với $t \leq maxRangeMove$, vd: với $maxRangeMove=3$ chúng tôi sẽ xem xét $move-1-point,move-2-point,move-3-point$. 
%Đương nhiên để công bằng chúng tôi thực hiện chia chi phí giảm được cho số lượng point trong move. 
Cụ thể với mỗi $i$ ta thực hiện lựa chọn lần lượt các chuỗi lộ trình con liên tiếp trong $truckRoute$ gồm $i$ điểm. Nếu có một điểm đã là điểm bay hay điểm hạ cánh của một \ac{DD} thì không xét chuỗi đó và thực hiện chuỗi tiếp theo (dòng 7-9). Ngược lại, ta sẽ thực hiện thiết lập \ac{DD} cho từng điểm trong chuỗi lộ trình (dòng 10- 24). Sau khi thiết lập hết các \ac{DD} ta kiểm tra xem chi phí giảm thu được có lớn nhất hiện tại không. Nếu có, ta lưu lại chi phí và chuỗi điểm. \\

Hàm $relocateAsDrone$ là thủ tục tính toán chi phí giảm đi khi chuyển một điểm thuộc \ac{TD} lên thành một \ac{DD}. Hàm này chúng tôi làm tương tự hàm $relocateAsDrone$ trong thuật toán \ref{alg:tspls}, chỉ khác để phù hợp với bài toán min-cost \ac{TSPkD} chúng ta phải cài đặt lại các hàm kiểm tra ràng buộc trong thủ tục. Hàm $caculateSavingPoints(j,i)$ là hàm tính chi phí giảm đi khi $truckRoute$ bị lấy $i$ phần tử từ $j$ được trình bày trong thuật toán \ref{alg:caculateSavingPoints}.
\begin{algorithm}[H]

\caption{move\_t\_point}
\textbf{Input:} tour, maxRangeMove\\
\textbf{Output:} Chi phí và vị trí giảm nhiều nhất.

\begin{algorithmic}[1]
\State moveMaxSaving=0;
\State $truckSubRoutes = \{truckRoute\};$
\For{$i=1, maxRangeMove$}

\For{$j=1, size(truckRoute)-i+1$}
\State $savings=caculateSavingPoints(j,i);$
\State Lấy toàn bộ $i$ point từ điểm $j$ ra khỏi $truckRoute$.
\If{Có một điểm không hợp lệ}
\State continue;
\EndIf
\For{$h=j,j+i$}
\State $aPointMaxSaving=0;$
\State $la^*=-1;$
\State $dr^*=-1;$
\State $re^*=-1;$
\ForEach{subroute in truckSubRoute}
\State $aPointSavings=0;$
\State $\begin{array}{l}

(pointmaxSavings,la,dr,re)= \\ relocateAsDrone(h,subroute,aPointSavings);\end{array}$
\If{$aPointMaxSaving<pointmaxSavings$}
\State $aPointMaxSaving=pointmaxSavings;$
\State $la^*=la;$
\State $dr^*=dr;$
\State $re^*=re;$
\EndIf
\EndFor	
\State $savings=savings+aPointMaxSaving;$
\State Thêm \ac{DD} vào danh sách \ac{DD} cho move.
\EndFor
%\State savings=savings/i;
\If{$moveMaxSaving<savings$}
\State $moveMaxSaving=savings$;
\State Lưu trạng thái đạt $moveMaxSavings$.
\EndIf
\State Đưa $truckRoute$ về trạng thái ban đầu.
\EndFor
\EndFor\\
\Return $moveMaxSavings$ và trạng thái đạt $moveMaxSavings$.
\end{algorithmic}
\label{alg:kpointmove}
\end{algorithm}

\chapter{Thử nghiệm và đánh giá}
Trong chương này chúng tôi thực hiện đánh giá các thuật toán. Cụ thể trong đồ án chúng tôi cài đặt 2 thuật toán là $TSP-LS \ Heuristic$ cho bài toán min-cost TSPD 1 drone và thuật toán $TSPkD-LS$ cho bài toán min-cost TSPkD 2, 3, 4 drones. Thực nghiệm được thực hiện trên  hai bộ dữ liệu một bộ theo bài báo \cite{main} và một bộ sinh bằng cách chọn ngẫu nhiên trên googlemap. 
\section{Dữ liệu}
Các tham số của mỗi bộ dữ liệu cụ thể như sau:
\begin{itemize}
\item Bộ 1 ( theo bài báo \cite{main}): 
\begin{itemize}
\item Tốc độ của xe tải: 40 km/h
\item Tốc độ của drone: 40 km/h
\item Chi phí trên 1km của xe tải: 25
\item Chi phí trên 1km của drone: 1
\item Khoảng thời gian tối đa hai phương tiện đợi nhau: 99999999 phút
\item Sức chịu đựng của drone: 13,33333 km
\item Bao gồm 35 tập dữ liệu với số điểm là 10 và 50.
\end{itemize}
Chú ý: Bộ dữ liệu có định nghĩa sẵn tập điểm giao hàng mà được phép giao hàng bởi drone.
\item Bộ 2: 
\begin{itemize}
\item Tốc độ của xe tải: 40 km/h
\item Tốc độ của drone: 40 km/h
\item Chi phí trên 1km của xe tải: 25
\item Chi phí trên 1km của drone: 1
\item Khoảng thời gian tối đa hai phương tiện đợi nhau: 15 phút
\item Sức chịu đựng của drone: 15 km
\item Bao gồm 10 tập dữ liệu với số điểm lần lượt 10, 20, 30, 40, 50 , tương ứng một số điểm có 2 tập dữ liệu. 
\end{itemize}
\end{itemize}
\section{Kết quả thử nghiệm}
Thuật toán được cài đặt bằng ngôn ngữ lập trình Java, chạy trên máy sử dụng hệ điều hành Window, cấu hình máy :
\begin{itemize}
\item CPU: Intel Core i5-2520M CPU @ 2,25 GHz.
\item Memory: 8Gb.
\end{itemize}
Trong thực nghiệm chúng tôi chon bộ tham số như sau : 
\begin{itemize}
\item Với thư viện CBLSVR: \begin{itemize}
\item MaxStable 50
\item MaxIter 300
\item TimeLimit 10
\end{itemize}
\item Với TSPD : \begin{itemize}
\item maxRangeMove 7
\end{itemize}
\end{itemize}
\begin{figure}

\begin{tikzpicture}
\begin{axis}[
    title={Biểu đồ thể hiện kết quả của k drone so với một drone (Bộ dữ liệu 1)},
    xlabel={Bộ dữ liệu},
    ylabel={\% chênh lệch so với kết quả tspd 1 drone},
    xmin=0, xmax=35,
    ymin=-6, ymax=5,
    xtick={0,5,10,15,20,25,30,35},
    ytick={-6,-5,-4,-3,-2,-1,0,1,2,3,4,5},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    width=1\textwidth,
    height=1\textwidth
]
 
\addplot %[
    %color=blue,
    %mark=square,
    %]
    coordinates {
    (0,0.0) (1,0.0) (2,0.0) (3,0.0) (4,0.0) (5,0.0) (6,0.0) (7,0.0) (8,0.0) (9,0.0) (10,0.0) (11,0.0) (12,0.0) (13,0.0) (14,0.0) (15,0.0) (16,0.0) (17,0.0) (18,0.0) (19,0.0) (20,0.0) (21,0.0) (22,0.0) (23,0.0) (24,0.0) (25,0.0) (26,0.0) (27,0.0) (28,0.0) (29,0.0) (30,0.0) (31,0.0) (32,0.0) (33,0.0) (34,0.0)
    };
    \legend{tspd 1 drone}
\addplot %[
    %color=green,
    %mark=square,
    %]
    coordinates {
    (0,0.0) (1,0.0) (2,0.0) (3,0.0) (4,-0.123) (5,0.6192) (6,0.7365) (7,-2.8665) (8,-1.8336) (9,-0.7531) (10,0.0) (11,-0.1032) (12,-2.2314) (13,-1.037) (14,-5.1677) (15,-0.0119) (16,0.0) (17,-1.4203) (18,-1.0971) (19,-4.6841) (20,-2.113) (21,-0.02) (22,-1.2465) (23,-3.8405) (24,-0.1765) (25,-0.2367) (26,0.5902) (27,0.0) (28,-5.0163) (29,0.0) (30,0.0) (31,-0.0279) (32,-0.1128) (33,-1.6792) (34,-3.9583)
    };
\addplot %[
   % color=orange,
   % mark=square,
   % ]
    coordinates {
   (0,0.0) (1,0.0) (2,0.0) (3,0.0) (4,-0.123) (5,0.6192) (6,0.7365) (7,-2.8946) (8,-1.8336) (9,-0.7531) (10,0.0) (11,-0.1032) (12,-2.2314) (13,-1.037) (14,-5.1515) (15,-0.0119) (16,0.0) (17,-1.4203) (18,-1.0971) (19,-5.0212) (20,-2.113) (21,-0.02) (22,-1.2975) (23,-3.8666) (24,-0.1765) (25,-0.2367) (26,0.5902) (27,0.0) (28,-5.0163) (29,0.0) (30,0.0) (31,-0.0279) (32,-0.2579) (33,-2.3781) (34,-3.9583)
    };
\addplot %[
    %color=purple,
    %mark=square,
    %]
    coordinates {
    (0,0.0) (1,0.0) (2,0.0) (3,0.0) (4,-0.123) (5,0.6192) (6,0.7365) (7,-2.9325) (8,-1.8336) (9,-0.7531) (10,0.0) (11,-0.1032) (12,-2.2314) (13,-1.037) (14,-5.2369) (15,-0.0119) (16,0.0) (17,-1.4203) (18,-1.0971) (19,-5.0212) (20,-2.113) (21,-0.02) (22,-1.2975) (23,-3.8666) (24,-0.1765) (25,-0.2367) (26,0.5902) (27,0.0) (28,-5.0163) (29,0.0) (30,0.0) (31,-0.0279) (32,-0.2579) (33,-2.3781) (34,-3.9583)
    };
 \legend{tspd 1 drone,tspd 2 drone,tspd 3 drone,tspd 4 drone} 
\end{axis}
\end{tikzpicture}
\caption{Biểu đồ thể hiện kết quả thuật toán với 1, 2, 3, 4 drone- Bộ dữ liệu 1}
\label{kqtspd1}
\end{figure}

Bảng \ref{tabletspkd1} chúng tôi thể hiện kết quả của bài toán \textit{min-cost TSPD} với 1, 2, 3, 4 drone. Két quả của bài toán \textit{tspd -1- drone } được chạy bởi thuật toán \textit{TSP-LS Heuristic} được trình bày trong phần \ref{section:tsp-ls}. Các kết quả ứng với bài toán 2, 3, 4 drone được chạy bởi thuật toán được trình bày trong chương \ref{chapter:tspkd}. Trong biểu đồ \ref{kqtspd1} thể hiện \% chênh lệch của bài toán min-cost TSPkD với 2,3,4 drone so với bài toán 1 drone. Công thức tính phần trăm chênh lệch như sau:
$$\%=\frac{\text{Chi phí của bài toán k drones - Chi phí của bài toán 1 drone}}{\text{Chi phí của bài toán 1 drone}} \times 100$$ 
\footnotesize
\begin{longtable}{|c|l|c|p{1.5cm}|c|p{1cm}|c|p{1cm}|c|p{1cm}|}
\caption{Bảng kết quả bộ dữ liệu 2 ứng với 1, 2, 3, 4 drones}
\label{tabletspkd1}\\ 
\toprule
STT&\multirow{2}{*}{Tập dữ liệu} & \multicolumn{2}{c|}{tspd-1-drone } &\multicolumn{2}{c|}{tspd-2-drone } &\multicolumn{2}{c|}{tspd-3-drone }&\multicolumn{2}{c|}{tspd-4-drone } \\
\cline{3-10} 
&&Chi phí &Thời gian (ms)&Chi phí &Thời gian (ms)&Chi phí &Thời gian (ms)&Chi phí &Thời gian (ms)\\
\midrule
        \toprule
0&$mbA101$ &     990.53 &      1.00 &     990.53 &       0.00 &     990.53 &       1.00 &     990.53 &       0.00\\ \hline 
1&$mbA102$ &     953.64 &      3.00 &     953.64 &       0.00 &     953.64 &       1.00 &     953.64 &       0.00\\ \hline 
2&$mbA103$ &     985.68 &      1.00 &     985.68 &       0.00 &     985.68 &       1.00 &     985.68 &       0.00\\ \hline 
3&$mbA104$ &     911.87 &      1.00 &     911.87 &       1.00 &     911.87 &       0.00 &     911.87 &       1.00\\ \hline 
4&$mbA105$ &     911.67 &      2.00 &     910.55 &       0.00 &     910.55 &       1.00 &     910.55 &       0.00\\ \hline 
5&$mbB101$ &    2086.51 & 228515.00 &    2099.51 &     488.00 &    2099.51 &     286.00 &    2099.51 &     382.00\\ \hline 
6&$mbB102$ &    1943.58 & 641944.00 &    1958.00 &     264.00 &    1958.00 &     308.00 &    1958.00 &     276.00\\ \hline 
7&$mbB103$ &    1925.97 & 471074.00 &    1872.30 &     350.00 &    1871.79 &     465.00 &    1871.10 &     480.00\\ \hline 
8&$mbB104$ &    2160.91 & 160644.00 &    2122.00 &      57.00 &    2122.00 &      68.00 &    2122.00 &      81.00\\ \hline 
9&$mbB105$ &    1983.99 & 378731.00 &    1969.16 &     148.00 &    1969.16 &     123.00 &    1969.16 &     126.00\\ \hline 
10&$mbB106$ &    2081.65 & 322429.00 &    2081.65 &      83.00 &    2081.65 &      80.00 &    2081.65 &      90.00\\ \hline 
11&$mbB107$ &    2066.85 & 253436.00 &    2064.72 &     248.00 &    2064.72 &     298.00 &    2064.72 &     293.00\\ \hline 
12&$mbB108$ &    2013.60 & 475925.00 &    1969.65 &     220.00 &    1969.65 &     242.00 &    1969.65 &     243.00\\ \hline 
13&$mbB109$ &    1967.11 &1026864.00 &    1946.92 &     298.00 &    1946.92 &     293.00 &    1946.92 &     295.00\\ \hline 
14&$mbB110$ &    2047.90 & 177981.00 &    1947.27 &     367.00 &    1947.57 &     350.00 &    1945.99 &     375.00\\ \hline 
15&$mbC101$ &    3964.19 &   8536.00 &    3963.72 &      61.00 &    3963.72 &      82.00 &    3963.72 &      83.00\\ \hline 
16&$mbC102$ &    3732.77 &   6601.00 &    3732.77 &     160.00 &    3732.77 &     182.00 &    3732.77 &     166.00\\ \hline 
17&$mbC103$ &    3713.82 &  15427.00 &    3661.81 &     417.00 &    3661.81 &     490.00 &    3661.81 &     450.00\\ \hline 
18&$mbC104$ &    4103.35 &  11749.00 &    4058.82 &     184.00 &    4058.82 &     233.00 &    4058.82 &     224.00\\ \hline 
19&$mbC105$ &    3848.47 &  23550.00 &    3676.27 &     606.00 &    3664.47 &     662.00 &    3664.47 &     892.00\\ \hline 
20&$mbC106$ &    4041.45 &  22180.00 &    3957.82 &     491.00 &    3957.82 &     354.00 &    3957.82 &     354.00\\ \hline 
21&$mbC107$ &    4146.52 &  10660.00 &    4145.69 &     109.00 &    4145.69 &     140.00 &    4145.69 &     146.00\\ \hline 
22&$mbC108$ &    3924.68 &  26514.00 &    3876.36 &     316.00 &    3874.41 &     359.00 &    3874.41 &     439.00\\ \hline 
23&$mbC109$ &    4044.95 &  17850.00 &    3895.35 &     246.00 &    3894.37 &     262.00 &    3894.37 &     305.00\\ \hline 
24&$mbC110$ &    3876.91 &  18155.00 &    3870.08 &     141.00 &    3870.08 &     166.00 &    3870.08 &     160.00\\ \hline 
25&$mbD101$ &    5559.54 &   7470.00 &    5546.41 &     216.00 &    5546.41 &     338.00 &    5546.41 &     292.00\\ \hline 
26&$mbD102$ &    6033.59 &   3932.00 &    6069.41 &     108.00 &    6069.41 &     142.00 &    6069.41 &     146.00\\ \hline 
27&$mbD103$ &    5603.71 &   5648.00 &    5603.71 &     311.00 &    5603.71 &     241.00 &    5603.71 &     234.00\\ \hline 
28&$mbD104$ &    5704.79 &  13405.00 &    5432.29 &     527.00 &    5432.29 &     752.00 &    5432.29 &     711.00\\ \hline 
29&$mbD105$ &    5726.94 &   4721.00 &    5726.94 &      97.00 &    5726.94 &     108.00 &    5726.94 &     102.00\\ \hline 
30&$mbD106$ &    5561.71 &   9631.00 &    5561.71 &     425.00 &    5561.71 &     356.00 &    5561.71 &     366.00\\ \hline 
31&$mbD107$ &    5869.62 &   3879.00 &    5867.98 &     110.00 &    5867.98 &     113.00 &    5867.98 &     110.00\\ \hline 
32&$mbD108$ &    5193.21 &   9347.00 &    5187.36 &     355.00 &    5179.85 &     415.00 &    5179.85 &     509.00\\ \hline 
33&$mbD109$ &    5990.58 &   6391.00 &    5891.65 &     177.00 &    5851.43 &     326.00 &    5851.43 &     414.00\\ \hline 
34&$mbD110$ &    5518.99 &   4487.00 &    5308.85 &     141.00 &    5308.85 &     136.00 &    5308.85 &     143.00\\ \hline 

\end{longtable}
\normalsize

\footnotesize
\begin{longtable}{|c|l|c|p{1.5cm}|c|p{1cm}|c|p{1cm}|c|p{1cm}|}
\caption{Bảng kết quả bộ dữ liệu 2 ứng với 1, 2, 3, 4 drones}
\label{tabletspkd2}\\ 
\toprule
STT&\multirow{2}{*}{Tập dữ liệu} & \multicolumn{2}{c|}{tspd-1-drone } &\multicolumn{2}{c|}{tspd-2-drone } &\multicolumn{2}{c|}{tspd-3-drone }&\multicolumn{2}{c|}{tspd-4-drone } \\
\cline{3-10} 
&&Chi phí &Thời gian (ms)&Chi phí &Thời gian (ms)&Chi phí &Thời gian (ms)&Chi phí &Thời gian (ms)\\
\midrule
\toprule
0&$data 10_1$&471& 3
&346& 5
&345& 3
&345& 2\\
\hline
1&$data 10_2$&908& 3
&560& 5
&617& 6
&616& 5 \\
\hline
2&$data 20_1$&1123& 721
&553& 44
&552& 35
&551& 80\\
\hline
3&$data 20_2$&1716&  336
&952& 48
&952& 61
&953& 63 \\
\hline
4&$data 30_1$&1438& 18864
&1132& 312
&1048& 304
&1004& 350 \\
\hline
5&$data 30_2$&2149& 15166
&1714& 292
&1713& 322
&1712& 374 \\
\hline

6&$data 40_1$&1254& 245945
&970& 1487
&998&  3269
&965& 3049 \\
\hline
7&$data 40_2$&1339& 334655
&1125& 979
&1131& 1271
&1119 &1402 \\
\hline

8&$data 50_1$&2418& 874590
&1500& 3454
&1523& 5536
&1444& 4055 \\
\hline

9&$data 50_2$ & 3779 & 294517
& 2864 &6131
&2859 &4897
&2857 &5954 \\
\hline





\end{longtable}
\normalsize
Kết quả trong bảng \ref{tabletspkd1} và biểu đồ \ref{kqtspd1} cho thấy rằng việc sử dụng nhiều hơn một drone kết quả thu được là tốt hơn. Cụ thể hầu hết các bộ dữ liệu bài toán ứng với 2, 3, 4 drone cho kết quả bằng hoặc tốt hơn 1 drone (trừ mbB101, mbB102, mbD102). Với bộ dữ liệu này kết quả của các bài toán ứng với 2, 3, 4 drone hầu như là tương đương nhau (trừ mbC105, mbC108, mbD108, \dots).

Trong bảng \ref{tabletspkd2} chúng tôi trình bày kết quả của thuật toán với bộ dữ liệu 2. Tương tự bộ 1, kết quả của bài toán \textit{tspd -1 drone } được chạy bởi thuật toán \textit{TSP-LS Heuristic}, kết quả ứng với bài toán 2, 3, 4 drone được chạy bởi thuật toán được trình bày trong \ref{chapter:tspkd}. Bộ dữ liệu 2 ứng với tập dữ liệu 10 đến 50 điểm bao gồm cả kho. Kết quả chi phí chênh lệch thu được được thể hiện trong đồ thị \ref{kqtspd2}.\\

Nhìn vào kết quả thu được trong bảng \ref{tabletspkd2} và biểu đồ  \ref{kqtspd2} chúng tôi cũng thêm một nữa khẳng định hơn việc sử dụng nhiều hơn 1 drone thu được kết quả tốt hơn sử dụng chỉ 1 drone.  Cụ thể kết quả ứng với bài toán 2, 3, 4 drone tốt hơn hẳn so với 1 drone trong tất cả các bộ dữ liệu. Hơn nữa thời gian chạy cũng thấp hơn do sinh một lúc nhiều \ac{DD} sẽ hạn chế được số vòng lặp phải thực hiện. Xét riêng với 2, 3, 4 drone kết quả chưa thực sự rõ rệt. Điều này cho thấy thuật toán có độ ổn định chưa thực sự tốt.
\begin{figure}

\begin{tikzpicture}
\begin{axis}[
    title={Biểu đồ thể hiện kết quả của k drone so với một drone(Bộ dữ liệu 2)},
    xlabel={Bộ dữ liệu},
    ylabel={\% chênh lệch so với kết quả tspd 1 drone},
    xmin=0, xmax=10,
    ymin=-150, ymax=5,
    xtick={0,1,2,3,4,5,6,7,8,9},
    ytick={-150,-100,-50,0,50},
    legend pos=south east,
    ymajorgrids=true,
    grid style=dashed,
    width=1\textwidth,
    height=1\textwidth
]
 
\addplot %[
    %color=blue,
    %mark=square,
    %]
    coordinates {
    (0,0.0) (1,0.0) (2,0.0) (3,0.0) (4,0.0) (5,0.0) (6,0.0) (7,0.0) (8,0.0) (9,0.0) 
    };
    \legend{tspd 1 drone}
\addplot %[
    %color=green,
    %mark=square,
    %]
    coordinates {
    (0,-36.1272) (1,-62.1429) (2,-103.0741) (3,-80.2521) (4,-27.0318) (5,-25.3792) (6,-29.2784) (7,-19.0222) (8,-61.2) (9,-31.9483) 
    };
\addplot %[
   % color=orange,
   % mark=square,
   % ]
    coordinates {
   (0,-36.5217) (1,-47.1637) (2,-103.442) (3,-80.2521) (4,-37.2137) (5,-25.4524) (6,-25.6513) (7,-18.3908) (8,-58.7656) (9,-32.1791) 
    };
\addplot %[
    %color=purple,
    %mark=square,
    %]
    coordinates {
   (0,-36.5217) (1,-47.4026) (2,-103.8113) (3,-80.063) (4,-43.2271) (5,-25.5257) (6,-29.9482) (7,-19.6604) (8,-67.4515) (9,-32.2716)
    };
 \legend{tspd 1 drone,tspd 2 drone,tspd 3 drone,tspd 4 drone} 
\end{axis}
\end{tikzpicture}
\caption{Biểu đồ thể hiện kết quả thuật toán với 1,2,3,4 drone - Bộ dữ liệu 2}
\label{kqtspd2}
\end{figure}
\footnotesize
\begin{longtable}{|c|l|c|p{1.5cm}|c|p{1cm}|c|p{1cm}|c|p{1cm}|}
\caption{Bảng kết quả bộ dữ liệu 2 ứng $move \ 1, 2, 3, 4 \ point$ cho bài toán min-cost TSPkD 2 drones}
\label{tabletspkd3}\\ 
\toprule
STT&\multirow{2}{*}{Tập dữ liệu} & \multicolumn{2}{c|}{move-1-point } &\multicolumn{2}{c|}{move-2-point } &\multicolumn{2}{c|}{move-3-point }&\multicolumn{2}{c|}{move-4-point } \\
\cline{3-10} 
&&Chi phí &Thời gian (ms)&Chi phí &Thời gian (ms)&Chi phí &Thời gian (ms)&Chi phí &Thời gian (ms)\\
\midrule
        \toprule
0&$data 10_1$&470& 1&
397& 1&
351 &3&
288& 1\\
\hline
1&$data 10_2$&794& 1&
746& 2&
693 &4&
590& 2 \\
\hline
2&$data 20_2$&1428 &17&
1004&  19&
1016& 114&
990& 39 \\
\hline
3&$data 20_1$&967& 19 &
817 &17&
738& 37&
672& 38\\
\hline
4&$data 30_1$&1740 &100&
1822& 153&
1487 &376&
1416& 209 \\
\hline

5&$data 30_2$&2168& 96&
1949& 146&
1844 &343&
1750 &235 \\
\hline
6&$data 40_1$&1269 & 294&
1280& 443&
1185& 1073&
1092& 985 \\
\hline
7&$data 40_2$&1299 & 482&
1065& 506&
1132 &1263&
1035 &959 \\
\hline
8&$data 50_1$&2041 &1407&
2029 &2005 &
1724 &4635 &
1993 & 2330\\
\hline
9&$data 50_2$ & 3500 & 1334 &
3163 & 1966 &
3099 & 3868 &
3094 & 2394\\
\hline

\end{longtable}
\normalsize
Chúng tôi thực hiện khảo sát toán tử $move-t-point$ để khẳng định chắc chắn hơn rằng việc áp dụng nhiều hơn 1 điểm sẽ đem lại kết quả tốt hơn  là sử dụng $relocate_D$ như bài toán 1 drone. Chúng tôi thực hiện khảo sát trên bài toán min-cost TSP2D (2 drone) với bộ dữ liệu 2 lần lượt các toán tử $move-1-drone$, $move-2-drone$, $move-3-drone$, $move-4-drone$. Tất nhiên trong phần này chúng tôi chỉ sử dụng đơn thuần toán tử $move-t-point$.
Trong bảng \ref{tabletspkd3} là chi phí và thời gian của bộ dữ liệu hai khi sử dụng các toán tử $move- 1, 2, 3, 4 -point$. Biểu đồ \ref{kqtspd3} thể hiện chi phí của các toán tử move ứng với từng bộ dữ liệu. \\

Kết quả trong bảng \ref{tabletspkd3} và biểu đồ \ref{kqtspd3}  khẳng định thêm lại giả thiết đưa ra ở phần \ref{subsection:ttmove} về việc sử toán tử $move-t-point$ với $t>1$ sẽ cho kết quả tốt hơn với bài toán min-cost TSPkD. Cụ thể với các bộ dữ liệu kết quả của $move-t-point$ với $t>1$ cho kết quả tốt hơn hoặc bằng $t=1$ (trừ trường hợp ở bộ dữ liệu $data30_1$ chi phí $move-2-point$ lớn hơn $move-1-point$).  
\begin{figure}
\begin{tikzpicture}
\begin{axis}[
    title={Biểu đồ thể hiện kết quả thuật toán với $move-1, 2, 3, 4 -point$ - Bộ dữ liệu 2},
    xlabel={Bộ dữ liệu},
    ylabel={Chi phí của lời giải},
    xmin=0, xmax=10,
    ymin=0, ymax=4000,
    xtick={0,1,2,3,4,5,6,7,8,9},
    ytick={1000,2000,3000,4000},
    legend pos=south east,
    ymajorgrids=true,
    grid style=dashed,
    width=1\textwidth,
    height=1\textwidth
]
 
\addplot %[
    %color=blue,
    %mark=square,
    %]
    coordinates {
(0,470.0) (1,794.0) (2,967.0) (3,1428.0) (4,1740.0) (5,2168.0) (6,1269.0) (7,1299.0) (8,2041.0) (9,3500.0)
    };
\addplot %[
    %color=green,
    %mark=square,
    %]
    coordinates {
   (0,397.0) (1,746.0) (2,817.0) (3,1004.0) (4,1822.0) (5,1949.0) (6,1280.0) (7,1065.0) (8,2029.0) (9,3163.0) 
    };
\addplot %[
   % color=orange,
   % mark=square,
   % ]
    coordinates {
  (0,351.0) (1,693.0) (2,738.0) (3,1016.0) (4,1487.0) (5,1844.0) (6,1185.0) (7,1132.0) (8,1724.0) (9,3099.0) 
    };
\addplot %[
    %color=purple,
    %mark=square,
    %]
    coordinates {
   (0,288.0) (1,590.0) (2,672.0) (3,990.0) (4,1416.0) (5,1750.0) (6,1092.0) (7,1035.0) (8,1993.0) (9,3094.0) 
    };
 \legend{move-1-point, move-2-point, move-3-point, move-4-point} 
\end{axis}
\end{tikzpicture}
\caption{Biểu đồ thể hiện kết quả thuật toán với $move-1, 2, 3, 4 -point$ - Bộ dữ liệu 2}
\label{kqtspd3}
\end{figure}
\chapter{Thiết kế và xây dựng chương trình ứng dụng}
Trong đồ án này chúng tôi xây dựng một chương trình ứng dựng web hỗ trợ người sử dụng lập kế hoạch vận chuyển hàng hóa. Kiến trúc của ứng dụng gồm 2 phần:(1) một web service chạy thuật toán, (2) một web-app cho nghiệp vụ và hiển thị sử dụng công nghệ ofbiz. Trong phần này chúng tôi xin phép chỉ  trình bày module (2). 
\section{Công nghệ sử dụng}
Công nghệ sử dụng chính trong xây dựng ứng dụng web là Apache Ofbiz. Ngoài ra chúng tôi còn sử dụng các công nghệ hiển thị để đem lại tính tiện dụng cho người dùng như GoogleMap hay bootstap.
\subsection{Công nghệ ofbiz}
Ofbiz xây dựng ứng dụng dựa trên mô hình MVC vì vậy việc xây dựng các ứng dụng trong ofbiz cũng phải tuân thủ theo mô hình này. 	
\subsubsection{Các thành phần trong Ofbiz}
\begin{itemize}
\item \textit{framework} là nơi chứa các thành phần hoạt đông chính của ofbiz như : kết nỗi cơ sở dữ liệu, caching, render screens, quản ly giao dịch \ldots. Đây là component được load đầu tiên khi hệ thống khởi động.
\item \textit{applications} đây là thành phần core của ofbiz nơi chứa các component nghiệp vụ như, quản lý nội dung, quản lý đơn hàng, \ldots

\item \textit{specialpurpose} bao gồm thêm các component và ứng dụng của ofbiz.
\item \textit{themes} bao gồm các resource cần thiết giao diện trong ofbiz.
\item \textit{hotdeploy} sử dụng để tạo các các component mới cho người sử dụng.
\end{itemize}
Để tạo một component mới trong hotdeploy ta đơn giản chị chạy task ant \textit{create-component} và nhập các thông tin cần thiết hệ thống sẽ tạo một thư mục là tên component vừa nhập vào trong hotdeploy. \\
\subsubsection{Các thành phần quan trọng trong một component}
\begin{itemize}
\item[-] \textit{config} chứa các config cho một component vd: $SlpUiLabels.xml$ chưa config về ngôn ngữ trong ofbiz, phục vụ cho chuyển đổi ngôn ngữ trong trang web.
\item[-] \textit{entitydef} chứa các định nghĩa về entity map với các bảng trong cơ sở dữ liệu.
\item[-] \textit{lib} chứa các thư viện java sử dụng component.
\item[-] \textit{servicedef} chứa các định nghĩa service.
\item[-] \textit{src} chứa code được sử dụng trong component.
\item[-] \textit{webapp} chứa controller, các view, resource của component.
\item[-] \textit{widget} chứa các định nghĩa về screen của component.
\end{itemize}
Các bước để tạo một luồng hoạt động trong ofbiz:
\begin{enumerate}
\item Bước 1: Tạo một định nghĩa mapping trong controller.xml.
\item Bước 2: Định nghĩa các service cần thiết cho mapping(nếu cần).
\item Bước 3: Định nghĩa screen cho mapping(nếu cần).
\item Bước 4: Tạo view .ftl cho mapping vừa tạo.
\end{enumerate}
\subsection{GoogleMap API}
Trong đồ án này chúng tôi sử dụng API của google map để truy vẫn thông tin thời gian quãng đường cho các điểm khách hàng và hiển thị giao diện web cho người sử dụng dễ thao tác. Google map java client được sử dụng trong server để truy vấn khoảng cách điểm, JavaScript api dược sử dụng ở client để hiển thị bản đồ cũng như những thao tác với bản đồ.
\subsection{Bootstrap}
Bootstrap là một framework kết hợp html, css và javascript cho phép ngưới sử dụng xây dựng view một cách đơn giản hơn mà vẫn đảm bảo reponsive. Bootstrap có một tập các thành phần định sẵn cho người sử dụng như layout, button, các ô input, tables \ldots
\section{Sơ đồ use-case}
\begin{figure}[H]

\begin{center}
\begin{tikzpicture}
\begin{umlsystem}[x=4, fill=red!10]{Hệ thống lập lịch vận tải hàng hóa}
\umlusecase{Tạo bộ dữ liệu}
\umlusecase[y=-2]{Sửa bộ dữ liệu}
\umlusecase[y=-4]{Lập lịch giao hàng}
\umlusecase[y=-6]{Hiển thị lịch giao hàng}
\umlusecase[y=-8]{Tải về kết quả lập lịch}
\umlusecase[y=-10]{Chuyển đổi ngôn ngữ}

\end{umlsystem}

\umlactor[x=-3, y=-5]{user}
\umlassoc{user}{usecase-1}
\umlassoc{user}{usecase-2}
\umlassoc{user}{usecase-3}
\umlassoc{user}{usecase-4}
\umlassoc{user}{usecase-5}
\umlassoc{user}{usecase-6}

\end{tikzpicture}
\end{center}
\caption{Sơ đồ use-case của ứng dụng}
\label{usecase}

\end{figure}
Trong đồ án này chúng tôi xây dựng một ứng dụng cơ bản cho chức năng cơ bản cho phép lập lịch vận tải hàng hóa bao gồm lên kế hoạch lập lịch và tải về kết quả. Cụ thể được liệt kê trong hình \ref{usecase}:
\begin{itemize}
\item[-] Case tạo bộ dữ liệu cho phép người sử dụng tạo một tập điểm cần giao hàng và điểm kho trên bản đồ sau đó lưu lại.
\item[-] Case sửa bộ dữ liệu cho phép người sử dụng sửa nhũng tập điểm giao hàng trước đó, thêm điểm, chỉnh sửa vị trí điểm.
\item[-] Case lập lịch giao  hàng cho phép chọn một tập dữ liệu trong hệ thống và chạy lập lịch.
\item[-] Case hiển thị lịch giao hàng cho phép ngưởi sử dụng nhìn thấy kết quả của case lập lịch giao hàng một cách động. Người sử dụng cũng có thể tải lên một kết quả có sẵn từ trước.
\item[-] Case tải về kết quả lập lịch cho phép người sử dụng tải về kết quả sau khi đã lập lịch. 
\item[-] Case chuyển đổi ngôn ngữ cho phép chuyển ngôn ngữ của ứng dụng sang tiếng Anh.
\end{itemize}
\section{Cơ sở dữ liệu}
Nhằm mục đích để lưu trữ các tập điểm yêu cầu của khách hàng chúng tôi tạo ra một cơ sở dữ liệu \ref{database} gồm 3 bảng: 
\begin{itemize}
\item Bảng point: chứa dữ liệu của một điểm giao hàng của khách hàng bào gồm các thông tin về tọa độ.
\item Bảng direction: chứa dữ liệu về khoảng cách, thời gian, chuỗi đường đi giữa hai điểm khách hàng.
\item Bảng dataset: chứa thông tin về tập điểm yêu cầu.
\end{itemize}
Trong data chúng tôi lưu trữ mỗi dataset gồm nhiều điểm yêu câu, cứ hai điểm trong dataset thì có một direction chứ thông tin giữa chúng. Thông tin direction được lấy từ googlemap.
\begin{figure}

\includegraphics[scale=0.6]{database.png}
\caption{Thiết kế cơ sở dữ liệu của ứng dụng}
\label{database}
\end{figure}
\section{Các màn hình}
Ứng dựn được thiết kế gồm các màn hình sau: 
\begin{itemize}
\item[-] Màn hình tạo và sửa bộ dữ liệu (\ref{makedata}, \ref{editdata}).
\item[-] Màn hình lập lịch (\ref{laplich})
\item[-] Màn hình hiển thị kết quả (\ref{solution1}, \ref{solution2}).
\end{itemize}
\begin{figure}

\includegraphics[scale=0.41]{screen/changeLanguage.png}
\caption{Màn hình thay đổi ngôn ngữ sang tiếng Anh}
\label{changelanguage}
\end{figure}

\begin{figure}

\includegraphics[scale=0.41]{screen/makedata.png}
\caption{Màn hình tạo dữ liệu lập lịch}
\label{makedata}
\end{figure}
\begin{figure}

\includegraphics[scale=0.41]{screen/editdata.png}
\caption{Màn hình chỉnh sửa tập dữ liệu}
\label{editdata}
\end{figure}
\begin{figure}

\includegraphics[scale=0.41]{screen/laplich.png}
\caption{Màn hình lập lịch}
\label{laplich}
\end{figure}
\begin{figure}

\includegraphics[scale=0.41]{screen/solution1.png}
\caption{Màn hình kết quả với một drone}
\label{solution1}
\end{figure}
\begin{figure}

\includegraphics[scale=0.41]{screen/solution2.png}
\caption{Màn hình kết quả với bốn drone}
\label{solution2}
\end{figure}
\addcontentsline{toc}{chapter}{Kết luận và hướng phát triển}
\chapter*{Kết luận và hướng phát triển}
Lập kế hoạch vận tải hàng hoá là một lĩnh vực đặc biệt quan trọng trong nền kinh tế mỗi quốc gia. Các mô hình vận tải mới không ngừng được đề xuất mang lại thuận tiện, giảm chi phí vận tải. Trong đồ án này, chúng tôi khảo sát mô hình vận tải hang hoá kết hợp xe tải và thiết bị bay Drone. Xe tải có khả năng vận chuyển các hàng hoá nặng, di chuyển trên hành trình dài, trong khi thiết bị bay Drone chỉ có khả năng vận chuyển hang hoá nhẹ, nhanh, nhưng quãng đường di chuyển ngắn do hạn chế về năng lượng nạp. 

Cụ thể, đồ án dựa trên nghiên cứu của Hà Quang Minh và cộng sự trong đó đề xuất thuật toán heuristics giải bài toán lập lộ trình vận tải kết hợp 1 xe tải và 1 thiết bị bay với mục tiêu là chi phí nhỏ nhất. Chúng tôi đã đề xuất thử nghiệm mô hình 1 xe tải kết hợp với nhiều thiết bị bay (2,3,4). Chúng tôi đã cài đặt thuật toán được đề xuất bởi Hà Quang Minh cho mô hình với nhiều Drone. Kết quả thử nghiệm cho thấy bằng việc kết hợp với nhiều hơn 1 drone thì chi phí sẽ giảm hơn so với việc sử dụng 1 drone.

Trong đồ án này, chúng tôi còn xây dựng một chương trình ứng dụng cho phép lên kế hoach và lập lịch sử dụng công nghệ Apache Ofbiz. Module gồm 2 phần là service thuật toán và webApp. Các chức năng có trong ứng dụng như tạo bộ dữ liệu, sửa bộ dữ liệu, lập lịch giao hàng, hiển thị lịch giao hàng, tải về kết quả lập lịch, chuyển đổi ngôn ngữ. 

Trong tương lai, chúng tôi sẽ cố gắng phát triển thuật toán trên các mô hình vận chuyển hàng hóa kết hợp xe tải và drone khác như: bài toán vận chuyển hàng hóa kết hợp xe tải và drone nhiều lộ trình, bài toán nhận hàng và đón hàng kết hợp xe tải và drone \ldots. Ngoài ra chúng tôi cũng thiết kế và cài đặt thêm một vài thuật toán với heuristic mới để đem lại kết quả tốt hơn nữa cho bài toán.

\begin{thebibliography}{9}
\bibitem{csplib30} Balanced Academic Curriculum Problem  \url{http://www.csplib.org/Problems/prob030/}
\bibitem{AIAMAB} Stuart Russell and Peter Norvig 
\textit{Artificial Intelligence: A Modern Approach} 2\textsuperscript{nd } edition, Prentice Hall, page 137,  2003.
\bibitem{ITA} Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein 
\textit{Introduction to Algorithms} 3\textsuperscript{rd } edition, MIT Press,  2009.
\bibitem{HCP} Francesca Rossi, Peter van Beek, Toby Walsh 
\textit{Handbook of Constraint Programming} 1\textsuperscript{st} edition, Elsevier Science,Chapter 2 Constraint Satisfaction:
An Emerging Paradigm,  2006.
\bibitem{MTH} El-Ghazali Talbi,
\textit{Metaheuristics
from design to implementation} 1\textsuperscript{st} edition, A Wiley-Intersience Publication John Wiley$\&$ Sons, inc ,  2009.
\bibitem{IP}Laurence A. Wolsey,
\textit{Integer Programming} 1\textsuperscript{st} edition
,A Wiley-Intersience Publication John Wiley$\&$ Sons, inc 
,1998.
\bibitem{TRR} Nguyễn Đức Nghĩa, Nguyễn Tô Thành 
\textit{Toán rời rạc} 3\textsuperscript{rd} edition, Nhà xuất bản đại học quốc gia Hà Nội, page 107-108,  2006.
\bibitem{TUHTT} Nguyễn Đức Nghĩa,  
\textit{Tối ưu hóa (quy hoạch tuyến tính và rời rạc)} 2\textsuperscript{nd} edition, Nhà xuất bản giáo dục,  1999.
\bibitem{main} Ha Quang Minh and Deville Yves and Pham Quang Dung and Ha Minh Hoang, \textit{On the min cost traveling salesman problem with drone}, arXiv preprint arXiv:1509.08764, 2015
\bibitem{bahiwww} S. Banker, Amazon and drones – here is why it will work (dec 2013).
URL \url{http://www.forbes.com/sites/stevebanker/2013/12/19/amazon-drones-here-is-why-it-will-work/}

\bibitem{12} C. C. Murray, A. G. Chu,\textit{The flying sidekick traveling salesman problem:
Optimization of drone-assisted parcel delivery}, Transportation Research
Part C: Emerging Technologies 54 (2015) 86–109.
\bibitem{13} N. Agatz, P. Bouman, M. Schmidt,\textit{Optimization approaches for the traveling salesman problem with drone}.
\bibitem{14} A. Ponza, \textit{Optimization of drone-assisted parcel delivery}.
\bibitem{15} X. Wang, S. Poikonen, B. Golden,\textit{ The vehicle routing problem with
drones: several worst-case results}, Optimization Letters (2016) 1–19.
\bibitem{16} L. K. Nozick, M. A. Turnquist,\textit{ Inventory, transportation, service quality and the location of distribution centers}, European Journal of Operational
Research 129 (2) (2001) 362–371.
\bibitem{17}] K. R. Dawn Russell, John J. Coyle, E. A. Thomchick, \textit{The real impact of
high transportation costs (jan 2014)}.
URL \url{http://www.supplychainquarterly.com/topics/Logistics/
910 20140311-the-real-impact-of-high-transportation-costs/}
\bibitem{18} A. Robinson, \textit{ Logistics and transportation expenses: Understanding their
role in the cost of doing business (feb 2014).}
\bibitem{19} N. Mathew, S. L. Smith, S. L. Waslander, \textit{ Planning paths for package de
livery in heterogeneous multirobot teams}, Automation Science and Engineering,
IEEE Transactions on 12 (4) (2015) 1298–1308.
\bibitem{21} G. Gutin, A. P. Punnen, \textit{ The traveling salesman problem and its variations}, Vol. 12, Springer Science \& Business Media, 2006.
URL \url{http://cerasis.com/2014/02/14/transportation-expenses/}
\bibitem{CBLSVR} Pham Quang Dung, Le Kim Thu, Nguyen Thanh Hoang, Pham Van Dinh, Bui Quoc Trung, \textit{ A Constraint-Based Local Search for offline and online general vehicle routing}, International Journal on Artificial Intelligence Tools, Vol. 26, No. 2, 2017
URL \url{https://doi.org/10.1142/S021821301750004X}.
\bibitem{AODTBT}Rupert Howell,Jonathon Wong
\textit{Apache OFBiz Development: The Beginner's Tutorial}, Paperback , page 53,  2008.
truyền.
\bibitem{AOC} Ruth Hoffman
\textit{Apache OFBiz Cookbook}, Paperback , page 28, 2010.
\bibitem{AOW} Apache Ofbiz
\url{https://ofbiz.apache.org/}

\end{thebibliography}


\end{document}
